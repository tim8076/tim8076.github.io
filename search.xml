<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(8) Hexo-第三方服務</title>
    <url>/2022/06/10/2022-6-10-2-Hexo-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8B%99/</url>
    <content><![CDATA[<h2 id="新增第三方服務"><a href="#新增第三方服務" class="headerlink" title="新增第三方服務"></a>新增第三方服務</h2><p>當我打開 <code>_config.next.yml</code> ，會發現NextT也整合了一些第三方服務進來，大多都只需要申請帳號並填入 ID 就可以使用。<br>以下就介紹幾個好用的服務。</p>
<h2 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h2><p>Disqus 是一個留言板服務，安裝流程如下</p>
<ol>
<li><p>到 <a href="https://disqus.com/">Disqus</a> 官網註冊一個帳號並登入。按下 <code>GET STARTED</code>按鈕，並選擇 <code> I want to install Disqus on my site</code>選項，就會來到 <code>Create a new site</code> 頁面。</p>
</li>
<li><p>輸入你的 <code>Website Name</code>，並按下 <code>Create Site </code>。</p>
</li>
<li><p>這邊就建立好你的 disqus帳號了</p>
</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061102.png?alt=media&token=518dfa72-a8fe-4c81-bead-89bc3a59e874" alt="disqus"></p>
<ol start="4">
<li>回到 <code>_config.next.yml</code>，將 disqus 選項改為true，並在shortname填入剛才在disqus設定的 <code>Website Name</code></li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061103.png?alt=media&token=3a8584ce-3749-4640-99c0-c8ecd574faa7" alt="disqus-setting"></p>
<ol start="5">
<li>以上就完成了留言板設置囉</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061104.png?alt=media&token=dc77ed95-13ce-4a34-9769-1297dc7c1bda" alt="comments"></p>
<h2 id="圖片顯示"><a href="#圖片顯示" class="headerlink" title="圖片顯示"></a>圖片顯示</h2><p>NextT 內建有兩種圖片顯示的方式，分別是 fancybox 和 mediumzoom，只要到 <code>_config.next.yml</code>，將選項改為true即可。但記得不要同時開啟 fancybox 和 mediumzoom。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061101.png?alt=media&token=c62c2900-a1e0-4d60-9a0a-bf13dc66d7a3" alt="image"></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>(7) Hexo-新增套件</title>
    <url>/2022/06/10/2022-6-10-1-Hexo-%E6%96%B0%E5%A2%9E%E5%A5%97%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="新增套件"><a href="#新增套件" class="headerlink" title="新增套件"></a>新增套件</h2><p>這章節會介紹一些NextT主題可以用的套件。</p>
<h2 id="hexo-generator-searchdb"><a href="#hexo-generator-searchdb" class="headerlink" title="hexo-generator-searchdb"></a>hexo-generator-searchdb</h2><p>這個套件可以讓你的部落格具有本地搜尋的功能，一樣先用NPM安裝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>安裝完後只要到你根目錄的 <code>_config.next.yml</code> 檔案裡，將 local search 改為true即可產生搜尋功能囉。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/20220601001.png?alt=media&token=a25eac63-0114-4674-9c02-7f7723f027e1" alt="search-option"></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/20220601002.png?alt=media&token=9b0afc38-cc99-4aef-abdc-68d318bc1c7e" alt="search-image"></p>
<h2 id="Reading-progress-bar-閱讀進度條"><a href="#Reading-progress-bar-閱讀進度條" class="headerlink" title="Reading progress bar 閱讀進度條"></a>Reading progress bar 閱讀進度條</h2><p>這個套件已經內建在NextT裡了，只要到  <code>_config.next.yml</code> 找到 reading_progress 選項，將enable改為true即可。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/20220601003.png?alt=media&token=61c1206c-5339-4a97-ae55-565d1d249f73" alt="reading-progress"></p>
<p>以上就是推薦可以安裝的套件囉</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) Node.js 安裝</title>
    <url>/2022/07/10/2022-07-10-1-nodeJs-install/</url>
    <content><![CDATA[<h2 id="什麼是-NodeJs"><a href="#什麼是-NodeJs" class="headerlink" title="什麼是 NodeJs"></a>什麼是 NodeJs</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/20220710.png?alt=media&token=094bcae5-8d76-462f-95e1-8ad790ab0fcd" alt="v8引擎"></p>
<p>Node.js是一個基於V8 JavaScript引擎的JavaScript執行環境，透過V8引擎將JavaScript程式碼編譯成機器語言讓電腦運作。除了nodeJS以外，像Chrome瀏覽器也使用了 V8 引擎來執行JavaScript。</p>
<h2 id="安裝-nodeJs"><a href="#安裝-nodeJs" class="headerlink" title="安裝 nodeJs"></a>安裝 nodeJs</h2><p>安裝nodeJs我們會先下載 <a href="https://github.com/coreybutler/nvm-windows/releases/tag/1.1.7">nvm</a>(nodeJs版本管理工具)，<br>選擇這個檔案下載<br><img src="https://cdn-images-1.medium.com/max/1100/1*MMtq_QXGr8WOb0PZBG38Gg.png" alt="setup"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm -v  // 查看安裝版本</span><br></pre></td></tr></table></figure>

<h2 id="nvm-指令"><a href="#nvm-指令" class="headerlink" title="nvm 指令"></a>nvm 指令</h2><p>nvm 可用的指令有這些: </p>
<ul>
<li>nvm list : 查看已安裝的版本</li>
<li>nvm list availabel : 查看可安裝的NodeJs版本</li>
<li>nvm install 版本號 :  安裝指定版本的NodeJs</li>
<li>nvm use 版本號 : 指定NodeJs版本</li>
</ul>
<p>輸入 nvm list available 確認可用的nodeJs版本 (選擇LTS穩定版)</p>
<p><img src="https://cdn-images-1.medium.com/max/1100/1*M3IU0v3oSFGFJ4tN31Awrw.png" alt="可用版本"></p>
<p>輸入 nvm install 版本號  下載nodeJs</p>
<p><img src="https://cdn-images-1.medium.com/max/1100/1*f1MaLlOhzZk_xukIsqFfrA.png" alt="nvm install"></p>
<p>安裝好後，可輸入 <code>node -v</code> 確認安裝的nodeJs版本。</p>
<p>因為下載nodeJs時，會順便下載npm，輸入npm -v 來確認版本。</p>
<p><img src="https://cdn-images-1.medium.com/max/1100/1*RkuPmVE75hwZt_PIwmX8SA.png" alt="npm -v"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) JS實作系列 Drum-Kit</title>
    <url>/2022/06/14/2022-6-14-1-JS30-Drum-Kit/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列文章會實做一些JS的範例，從中熟練JS的觀念。</p>
<p>本文從第一個範例開始 Drum-Kit <a href="https://codepen.io/tim-chou/pen/oNEmjKR">範例程式碼</a></p>
<p><img src="https://miro.medium.com/max/1400/1*wUokqgRhKPwqMbffW1lZeA.png" alt="piano"></p>
<h2 id="keycode綁定"><a href="#keycode綁定" class="headerlink" title="keycode綁定"></a>keycode綁定</h2><p>在這次挑戰中，要完成的是按下琴鍵後，播放指定音樂，和改變樣式。</p>
<p>所以第一步要做的是，選出指定的dom元素和音檔，</p>
<p>在 html 結構中，用 data-key分別對div 跟 audio 元素綁定對應按鍵的 keycode。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-key</span>=<span class="string">&quot;65&quot;</span> <span class="attr">class</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">data-key</span>=<span class="string">&quot;65&quot;</span> <span class="attr">src</span>=<span class="string">&quot;sounds/clap.wav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件監聽"><a href="#事件監聽" class="headerlink" title="事件監聽"></a>事件監聽</h2><p>要讓使用者能彈出聲音，要在window建立 keydown事件的監聽，當使用者按下鍵盤時，觸發對應函式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>,playHandeler,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">playHandeler</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">//播音樂</span></span><br><span class="line">  <span class="keyword">const</span> audio = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`audio[data-key=&quot;<span class="subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);</span><br><span class="line">  <span class="keyword">if</span>(audio)&#123;</span><br><span class="line">    audio.<span class="property">currentTime</span> = <span class="number">0</span>;<span class="comment">//若要連續撥放 要設為0</span></span><br><span class="line">    audio.<span class="title function_">play</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//改樣式</span></span><br><span class="line">  <span class="keyword">const</span> dom = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`div[data-key=&quot;<span class="subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);</span><br><span class="line">  <span class="keyword">if</span>(dom)&#123;</span><br><span class="line">    dom.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;playing&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函式中，用 ES6 的選取方法，用 <code>audio[data-key=”$&#123;e.keyCode&#125;”]</code>直接選到 HTML 中的 [data-key]。<br>在利用 if 判斷式，判斷當使用者按到指定的按鍵時，也就是audio為true時，執行播放音檔，audio.play();<br>dom 為true時，執行classList.add()，彈奏時增加樣式。</p>
<h2 id="動畫結束時，拿掉樣式"><a href="#動畫結束時，拿掉樣式" class="headerlink" title="動畫結束時，拿掉樣式"></a>動畫結束時，拿掉樣式</h2><p>利用foreach，對每一個.key建立監聽，監聽事件為 transitionend 。這個事件是在css的 transition結束時觸發，也就是每一個drum kit撥放完時觸發。<br>要注意，若執行的transition屬性有很多種，如 transform、color、border-color，transitionend 會重複的觸發。<br>今天我們希望的是，在transform動畫結束時拿掉樣式，所以要加上判斷propertyName為 transform時，再執行 classList.remove拿掉樣式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.key&#x27;</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">  item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;transitionend&#x27;</span>, transitionendHandler)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transitionendHandler</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">propertyName</span> === <span class="string">&#x27;transform&#x27;</span>)&#123;</span><br><span class="line">    e.<span class="property">currentTarget</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;playing&#x27;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="額外補充"><a href="#額外補充" class="headerlink" title="額外補充"></a>額外補充</h2><p>若要在html 顯示 鍵盤按鍵 可以用 <code>&lt;kbd&gt;&lt;/kbd&gt;</code> 元素。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JS實作系列</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) Gulp-介紹與安裝</title>
    <url>/2022/06/15/2022-6-15-2-Gulp-%E4%BB%8B%E7%B4%B9%E8%88%87%E5%AE%89%E8%A3%9D/</url>
    <content><![CDATA[<h2 id="Gulp-是什麼"><a href="#Gulp-是什麼" class="headerlink" title="Gulp 是什麼"></a>Gulp 是什麼</h2><p>在以前做網頁開發時，可能只需要處理html、css、js檔案就可以了。但現在前端開發工具越來越多，像css有scss的預處理器、html可以用pug來寫等等。此時就須要一個工具來將這些scss、pug檔案編譯成css跟html。<br>Gulp 就可以用來編譯 Sass、編譯 JavaScript 語法至相容性較高的 ES5、圖片優化壓縮、打包程式碼等等的事情，讓開發者可以專注於開發。</p>
<h2 id="安裝流程"><a href="#安裝流程" class="headerlink" title="安裝流程"></a>安裝流程</h2><h3 id="安裝node-js與npm"><a href="#安裝node-js與npm" class="headerlink" title="安裝node.js與npm"></a>安裝node.js與npm</h3><p>首先我們需要要先安裝 <a href="https://nodejs.org/en/">nodejs</a>，我們選擇穩定版(LTS)來安裝，安裝過程就不再贅述。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061501.png?alt=media&token=3db09d20-f796-4c7b-8c12-0e894845871f" alt="nodejs"></p>
<p>安裝好後，到vscode編輯器，輸入下列指令來確認是否安裝完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v   </span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>若有正確安裝，會顯示版本號。</p>
<h2 id="安裝全域的-Gulp"><a href="#安裝全域的-Gulp" class="headerlink" title="安裝全域的 Gulp"></a>安裝全域的 Gulp</h2><p>在commend line輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp -g  //windows系統</span><br><span class="line">sudo npm install gulp -g //Mac系統</span><br></pre></td></tr></table></figure>
<p>npm安裝套件分為全域與專案安裝，全域安裝只需安裝一次即可。</p>
<h2 id="安裝專案的Gulp"><a href="#安裝專案的Gulp" class="headerlink" title="安裝專案的Gulp"></a>安裝專案的Gulp</h2><p>我們先用vscode開一個新的資料夾作為這次專案使用。</p>
<p>先在commend line 輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>輸入完後，會新增一個package.json檔案，這個檔案會用來管理這個專案的套件。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061502.png?alt=media&token=b12ce94d-b001-4fa8-b8b2-2912c6dca318" alt="package.json"></p>
<p>之後輸入下面指令來安裝專案內的gulp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp --save</span><br></pre></td></tr></table></figure>

<p>安裝完成後輸入下面指令檢查一下，有正確安裝會顯示版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp -v</span><br></pre></td></tr></table></figure>

<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>到這邊就完成專案內gulp的安裝，下一堂課會帶大家新增一個gulp file，做一些好玩的功能囉。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(2) JS實作系列 時鐘</title>
    <url>/2022/06/15/2022-6-15-1-JS30-clock/</url>
    <content><![CDATA[<p><img src="https://miro.medium.com/max/1400/1*JH-e_9OQS1lBH7hqb7lMXQ.png" alt="clock"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這次要在網頁實作一個時鐘，本次的 <a href="https://codepen.io/tim-chou/pen/RwReNQx">範例code</a></p>
<p>首先在 HTML 中新增 三組 DIV 分別為時、分、秒針</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clock&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clock-face&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hand second-hand&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hand min-hand&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hand hour-hand&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>時、分、秒針都設定為寬高是鐘面100%的正方形，並利用偽元素的方式，將指針加在正方形上，所以我們之後實際旋轉的是正方形。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hand</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1040/1*hxPjvHGmPHvKxnY7ZZFuUg.png" alt="hand"></p>
<h2 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h2><p>在js中，首先選取 時、分、秒針</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> second = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.second-hand&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> min = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.min-hand&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> hour = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.hour-hand&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在setClock函式中，利用 建立 new Date() 取得時間，再用getSeconds、getMinutes、getHours取得秒、時、分。<br>並分別乘上 6 度 (每秒鐘在鐘面佔的角度 )、30度(每小時在鐘面佔的角度)，並利用 .style.transform &#x3D; <code>rotate($&#123;minDeg&#125;deg)</code>的方式指定角度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">setClock</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> secondDeg = date.<span class="title function_">getSeconds</span>() * <span class="number">6</span> <span class="comment">// (360/60)每分鐘所佔的角度</span></span><br><span class="line">  <span class="keyword">let</span> minDeg = date.<span class="title function_">getMinutes</span>() * <span class="number">6</span> + date.<span class="title function_">getSeconds</span>()* <span class="number">30</span> / <span class="number">60</span> <span class="comment">// (360/60)每秒所佔的角度</span></span><br><span class="line">  <span class="keyword">let</span> hourDeg = date.<span class="title function_">getHours</span>() * <span class="number">30</span> + date.<span class="title function_">getMinutes</span>()* <span class="number">30</span> / <span class="number">60</span><span class="comment">// (360/12)每小時時針所佔的角度 </span></span><br><span class="line"></span><br><span class="line">  second.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;secondDeg&#125;</span>deg)`</span></span><br><span class="line">  min.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;minDeg&#125;</span>deg)`</span></span><br><span class="line">  hour.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate(<span class="subst">$&#123;hourDeg&#125;</span>deg)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後用 setInterval 每過一秒就執行一次 setClock 函式，就完成拉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(setClock,<span class="number">1000</span>); <span class="comment">//設定間隔，持續執行</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JS實作系列</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>(4) Gulp-編譯scss</title>
    <url>/2022/06/16/2022-6-15-4-Gulp-%E7%B7%A8%E8%AD%AFsass/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這篇來介紹如何在 gulp 中，進行scss的編譯吧。</p>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>首先來安裝 gulp-sass 套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install sass gulp-sass --save</span><br></pre></td></tr></table></figure>

<h2 id="載入設定"><a href="#載入設定" class="headerlink" title="載入設定"></a>載入設定</h2><p>在gulpfile.js裡，依照文件貼上相關設定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-sass&#x27;</span>)(<span class="built_in">require</span>(<span class="string">&#x27;sass&#x27;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildStyles</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./source/scss/**/*.scss&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">sass</span>().<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, sass.<span class="property">logError</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/css&#x27;</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面為編譯scss的gulp任務，用 src 指定 scss 所在的資料夾後，最後在用gulp.dest() 指定編譯後的 css 輸出的位置。</p>
<p>之後在scss資料夾裡，新增一個all.scss檔案。</p>
<p>並輸入一些東西</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color</span>: <span class="number">#00cc99</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$color</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在commend line 輸入 gulp buildStyles 就可以發現scss被編譯成css檔案，並輸出到public資料夾囉。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(3) Gulp-撰寫gulp file</title>
    <url>/2022/06/16/2022-6-15-3-Gulp-%E5%9F%BA%E7%A4%8E%E7%AF%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已經將專案的環境與gulp都安裝好了，這節會開始介紹如何撰寫你的第一支 gulp file</p>
<h2 id="開始撰寫-gulp-file"><a href="#開始撰寫-gulp-file" class="headerlink" title="開始撰寫 gulp file"></a>開始撰寫 gulp file</h2><p>一開始先在專案的根目錄新增一個檔案 <code>gulpfile.js</code>檔案</p>
<p>然後在根目錄 新增一個 <code>source</code> 資料夾<br>並在source資料夾內新增一個 style.css</p>
<p><img src="https://i.imgur.com/GsAJaOF.png" alt="img"></p>
<p>在gulpfile.js 最上面先引入 GULP</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>然後我們可以新增一個簡單的gulp任務</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">funciton <span class="title function_">copyFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">   gulp.<span class="title function_">src</span>(<span class="string">&#x27;./source/**/*/.css&#x27;</span>)</span><br><span class="line">     .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/css&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面這段程式中，我們用了 <code>gulp.src()</code> 來指定來源檔案的位置，<br>並用 <code>gulp.dest()</code> 將檔案輸出到指定的public資料夾。</p>
<p>然後可以開啟 commend line 輸入指令 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp copyFile</span><br></pre></td></tr></table></figure>

<p>就會發現檔案已經被輸出到 public 資料夾囉。</p>
<p>下堂課會開始介紹 其他的各種gulp任務喔。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(2) Gulp-運作原理介紹</title>
    <url>/2022/06/16/2022-6-15-5-Gulp-%E9%81%8B%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/1200/0*_uAjbnaZaXs1ca6x.png" alt="img"></p>
<h2 id="運作原理"><a href="#運作原理" class="headerlink" title="運作原理"></a>運作原理</h2><p>Gulp運作的方式就是將每個任務像水管一樣串接下去</p>
<h2 id="簡單範例"><a href="#簡單範例" class="headerlink" title="簡單範例"></a>簡單範例</h2><p><img src="https://cdn-images-1.medium.com/max/1200/1*uBz4qK1ZMgkS6fNfP8u-NA.png" alt="gulp"></p>
<p>上圖是一個copy html檔案的簡單範例，主要如下:</p>
<ol>
<li>gulp.task(‘任務名稱’, function(){}): 指定一個gulp任務</li>
<li>gulp.src: 指定資料來源</li>
<li>gulp.pipe(): 指定事件，pipe就像水管，可以一個接一個</li>
</ol>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*FWZTmYZm1Sbg5FIO0ZDycg.png" alt="pipe"></p>
<ol start="4">
<li>gulp.dest(): 輸出任務的結果</li>
</ol>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(8) Gulp-檔案壓縮</title>
    <url>/2022/06/17/2022-6-17-4-Gulp-compress/</url>
    <content><![CDATA[<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><ol>
<li>壓縮 css套件: <a href="https://www.npmjs.com/package/gulp-clean-css">gulp-clean-css</a></li>
<li>壓縮 js套件: <a href="https://www.npmjs.com/package/gulp-uglify">gulp-uglify</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp-clean-css gulp-uglify --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="載入設定"><a href="#載入設定" class="headerlink" title="載入設定"></a>載入設定</h2><p>壓縮css的部分，可以在編譯完scss後，進行壓縮</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sassTask</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> plugins = [</span><br><span class="line">    <span class="title function_">autoprefixer</span>(),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./source/scss/**/*.scss&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">init</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">sass</span>(&#123;</span><br><span class="line">      <span class="attr">includePaths</span>: [<span class="string">&#x27;./node_modules/bootstrap/scss&#x27;</span>]</span><br><span class="line">    &#125;).<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, sass.<span class="property">logError</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">postcss</span>(plugins))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">cleanCss</span>(&#123; <span class="attr">compatibility</span>: <span class="string">&#x27;ie8&#x27;</span> &#125;)))</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">write</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/css&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(browserSync.<span class="title function_">stream</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*mpisvD3qy987427Pd2n-kg.png" alt="壓縮css程式碼"></p>
<p>壓縮js的部分，可在babel編譯完後並且合併後( concat ) 進行壓縮</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">babel</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./source/js/**/*.js&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">init</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">concat</span>(<span class="string">&#x27;all.js&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">uglify</span>()))</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">write</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/js&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(browserSync.<span class="title function_">stream</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn-images-1.medium.com/max/1200/1*1anhKo-vPFyBKX4scALEZw.png" alt="壓縮js"></p>
<h2 id="壓縮成果"><a href="#壓縮成果" class="headerlink" title="壓縮成果"></a>壓縮成果</h2><ol>
<li>css被壓成一行</li>
</ol>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*tweaZBqP0_OJL3SnSgi-fQ.png" alt="css"></p>
<ol start="2">
<li>js被壓成一行</li>
</ol>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*O3lohBob7h6KxqHGfVvong.png" alt="js"></p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(5) Gulp-postcss</title>
    <url>/2022/06/17/2022-6-17-1-Gulp-postcss/</url>
    <content><![CDATA[<h2 id="PostCSS-是什麼"><a href="#PostCSS-是什麼" class="headerlink" title="PostCSS 是什麼 ?"></a>PostCSS 是什麼 ?</h2><p>PostCSS 是一個使用JavaScript 轉換CSS 的工具。<br>以前在撰寫css時，因為有些新的語法舊的瀏覽器不支援，所以需要加上前贅詞</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*0gGNaqjQjKhcOhyBck5Bhw.png" alt="img"></p>
<p>但這步驟如果用人工判斷很費時，此時可以用post css搭配 autoprfixer 套件，來自動加入這些前贅詞。</p>
<h2 id="安裝流程"><a href="#安裝流程" class="headerlink" title="安裝流程"></a>安裝流程</h2><p>先安裝套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install postcss gulp-postcss autoprfixer --save</span><br></pre></td></tr></table></figure>

<p>然後在 <code>gulpfile.js</code> 中載入套件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> postcss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-postcss&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在我們編譯sass的任務中，加入postcss功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sassTask</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> plugins = [</span><br><span class="line">    <span class="title function_">autoprefixer</span>(),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./source/scss/**/*.scss&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">sass</span>().<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, sass.<span class="property">logError</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(<span class="title function_">postcss</span>(plugins))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/css&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我們先新增一個 plugins 的變數，並在編譯成css後，加入 <code>postcss(plugins)</code></p>
<p>此時可能會遇到這個錯誤</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*r49hPlucU_l7u-wYZtzGBg.png" alt="error"></p>
<p>這個錯誤是要我們在根目錄增加一個 .browserslistrc 的檔案，裡面放需要支援的瀏覽器版本條件，如下圖:</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*RiUzC2vYWqZEFgT0nCa7lA.png" alt="browser"></p>
<p>之後如果要調整 CSS 支援版本就只需要調整 .browserslistrc 中的 last X version X 即可，關於支援版本設定，可參考<a href="https://github.com/browserslist/browserslist">這裡</a>。</p>
<p>以上就完成gulp-postcss的的設定囉</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(6) Gulp-babel</title>
    <url>/2022/06/17/2022-6-17-2-Gulp-babel/</url>
    <content><![CDATA[<h2 id="什麼是-babel"><a href="#什麼是-babel" class="headerlink" title="什麼是 babel"></a>什麼是 babel</h2><p>使用babel套件，可以將 一些新的js語法，如箭頭函式、let、const，編譯為舊版瀏覽器看得懂的語法。</p>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev gulp-babel @babel/core @babel/preset-env</span><br><span class="line">npm install --save gulp-sourcemaps  //壓縮後，可標記原始碼位置</span><br><span class="line">npm install --save gulp-concat  //合併程式碼用</span><br></pre></td></tr></table></figure>

<p>在 gulpfile.js 中引入任務</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">babel</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./source/js/**/*.js&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">concat</span>(<span class="string">&#x27;all.js&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/js&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函式中，我們指定source資料夾裡的 js檔案進行用babel編譯，<br>並用concat套件將多支js檔案在輸出時合併成一支，最後用dest輸出到public資料夾。</p>
<h2 id="sourcemap套件"><a href="#sourcemap套件" class="headerlink" title="sourcemap套件"></a>sourcemap套件</h2><p>因為多支js檔案，最後會被編譯成同一支js。為了在最終編譯的js中，查找原先程式碼的位置，可以使用 sourcemap套件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">babel</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./source/js/**/*.js&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">init</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">concat</span>(<span class="string">&#x27;all.js&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">write</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/js&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn-images-1.medium.com/max/1200/1*ZT2zdCDxGvinb_v13KRccQ.png" alt="sourcemaps"></p>
<p>sourcemap 除了js檔案以外，也可以用在如scss檔案</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*nQzF8npRYhWcAaXJAzGgDw.png" alt="scss-source"></p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
        <tag>gulp-babel</tag>
      </tags>
  </entry>
  <entry>
    <title>(10) Gulp 釋出開發成品</title>
    <url>/2022/06/18/2022-6-18-2-Gulp-result/</url>
    <content><![CDATA[<h2 id="安裝-gulp-clean"><a href="#安裝-gulp-clean" class="headerlink" title="安裝 gulp clean"></a>安裝 gulp clean</h2><p>在gulp專案中，有時我們可能在source資料夾裡有一些test檔案，是不該被編譯到public資料夾內的。但無法記得到底哪些test已經被編譯，那些沒有。此時就可以用 gulp clean、gulp-sequence來清理最終的public資料夾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp-clean --save</span><br></pre></td></tr></table></figure>

<p>建立一個 clean 任務</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clean</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;./public&#x27;</span>], &#123; <span class="attr">read</span>: <span class="literal">false</span>, <span class="attr">allowEmpty</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">clean</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 clean 任務，刪除如 .tmp(暫存資料夾)、public資料夾，目的是將資料夾刪除後，重新編譯。</p>
<h2 id="gulp-parallel、series"><a href="#gulp-parallel、series" class="headerlink" title="gulp parallel、series"></a>gulp parallel、series</h2><p>在 gulp4.0 中新增了 parallel、series兩個方法</p>
<ol>
<li>parallel : 任務同時執行</li>
<li>series : 任務依序執行</li>
</ol>
<p>我們可以用這兩個方法，讓我們之前建立的各種gulp任務，依序或同時執行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">build</span> = gulp.<span class="title function_">series</span>(clean, ejs, sassTask, babel, vendorsJs)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">default</span> = gulp.<span class="title function_">series</span>(clean, ejs, sassTask, babel, vendorsJs, gulp.<span class="title function_">parallel</span>(watch, browser))</span><br></pre></td></tr></table></figure>

<p>在 <code>gulpfile.js</code> 的最後，分別輸出build跟default指令。 </p>
<ul>
<li>default: 為預設指令，在commend line上輸入 gulp 即可執行。</li>
<li>build: 用來產出成品，在commend line上輸入 gulp build 即可執行。</li>
</ul>
<p>在 gulp.series() 中我們依序執行 clean、ejs、sass等任務，但要注意，在 export.default是開發時使用，所以加上了watch， browser等監聽的任務，若在build成品，則不需加入。</p>
<h2 id="完成程式碼參考"><a href="#完成程式碼參考" class="headerlink" title="完成程式碼參考"></a>完成程式碼參考</h2><p><a href="https://github.com/tim8076/gulp-project/blob/main/gulpfile.js">參考範例</a></p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(9) Gulp-if</title>
    <url>/2022/06/18/2022-6-18-1-Gulp-if/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常在開發項目時，我們會分所謂的 development(開發環境) 與 production(生產環境)，在開發環境時，我們不會壓縮檔案，直到生產環境時，才會做檔案壓縮。此時，可以用 Minimist 命令行參數解析工具區分 Gulp 套件在 development 與 production 環境下的使用。</p>
<h2 id="Minimist-套件安裝"><a href="#Minimist-套件安裝" class="headerlink" title="Minimist 套件安裝"></a>Minimist 套件安裝</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install minimist   </span><br><span class="line">$ npm install gulp-if</span><br></pre></td></tr></table></figure>

<p>在gulpfile.js 中，載入 minimist</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> minimist= <span class="built_in">require</span>(<span class="string">&#x27;minimist&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="設定環境參數"><a href="#設定環境參數" class="headerlink" title="設定環境參數"></a>設定環境參數</h2><p>並設定envOption環境參數，以下面範例來說，預設是帶入字串，並且是develop這個環境。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> envOption = &#123;</span><br><span class="line">  <span class="attr">string</span>: <span class="string">&#x27;env&#x27;</span>,</span><br><span class="line">  <span class="attr">default</span>: &#123; <span class="attr">env</span>: <span class="string">&#x27;dev&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用minimist將環境參數讀入，並在後方帶入 envOption環境選項。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="title function_">minimist</span>(process.<span class="property">argv</span>.<span class="title function_">slice</span>(<span class="number">2</span>), envOption)</span><br></pre></td></tr></table></figure>

<p>process.argv.slice(2) 這行意思是跳過前兩個 – 字元直接讀取 env 這個字串。<br>此時用console.log(options)，可以看到options目前環境參數是 develop</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*b1cLVsVXiWwj834lXdwTYA.png" alt="console"></p>
<p>若要更改參數，則可用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp --env 參數名稱</span><br></pre></td></tr></table></figure>

<p>例如我在commend line 上輸入 <code>gulp --env prod</code> 就可將環境參數從dev改成prod。</p>
<h2 id="使用gulp-if套件搭配環境參數"><a href="#使用gulp-if套件搭配環境參數" class="headerlink" title="使用gulp-if套件搭配環境參數"></a>使用gulp-if套件搭配環境參數</h2><p>環境參數設定好後，就可用gulp-if套件來判斷當前環境是 開發環境(dev) 還是 生產環境 (prod)。<br>讓我們能判斷如果是生產環境，則壓縮檔案，如果不是則不壓縮檔案。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">babel</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(path.<span class="property">js</span>.<span class="property">src</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">init</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">concat</span>(<span class="string">&#x27;all.js&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">if</span>(options.<span class="property">env</span> === <span class="string">&#x27;prod&#x27;</span>, $.<span class="title function_">uglify</span>()))</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">write</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(path.<span class="property">js</span>.<span class="property">des</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(browserSync.<span class="title function_">stream</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我們用了 gulp-if 來判斷當前環境變數是不是 prod，是的話則執行 uglify來壓縮。</p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(7) Gulp-browserSync</title>
    <url>/2022/06/17/2022-6-17-3-Gulp-browser-sync/</url>
    <content><![CDATA[<h2 id="什麼是-broswer-sync"><a href="#什麼是-broswer-sync" class="headerlink" title="什麼是 broswer sync"></a>什麼是 broswer sync</h2><p>browserSync 能建立起一個暫時性的開發用伺服器。搭配 gulp 使用，就能達成檔案修改時，browserSnyc 會自動重整畫面，讓開發者能在瀏覽器上即時看到修改後的畫面。</p>
<h2 id="安裝流程"><a href="#安裝流程" class="headerlink" title="安裝流程"></a>安裝流程</h2><p>網址: <a href="https://browsersync.io/docs/gulp">https://browsersync.io/docs/gulp</a></p>
<p>安裝套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install browser-sync gulp --save</span><br></pre></td></tr></table></figure>

<p>在gulpfile.js中引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">&#x27;browser-sync&#x27;</span>).<span class="title function_">create</span>();</span><br></pre></td></tr></table></figure>

<p>建立任務，指定伺服器位置為最後輸出的public資料夾</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">browser</span>(<span class="params"></span>)&#123;</span><br><span class="line">  browserSync.<span class="title function_">init</span>(&#123;</span><br><span class="line">    <span class="attr">server</span>: &#123; <span class="attr">baseDir</span>: <span class="string">&quot;./public&quot;</span> &#125;,</span><br><span class="line">    <span class="attr">reloadDebounce</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其他gulp任務輸出的最後加上 <code>.pipe(browserSync.stream())</code></p>
<p>如在babel任務加上，就會在babel更新後，自動同步到瀏覽器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">babel</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(path.<span class="property">js</span>.<span class="property">src</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">init</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">babel</span>(&#123;</span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">concat</span>(<span class="string">&#x27;all.js&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">if</span>(options.<span class="property">env</span> === <span class="string">&#x27;prod&#x27;</span>, $.<span class="title function_">uglify</span>()))</span><br><span class="line">    .<span class="title function_">pipe</span>($.sourcemaps.<span class="title function_">write</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(path.<span class="property">js</span>.<span class="property">des</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(browserSync.<span class="title function_">stream</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>(11) Gulp-git</title>
    <url>/2022/06/18/2022-6-18-3-Gulp-git/</url>
    <content><![CDATA[<h2 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h2><p>這章節，我們來幫gulp專案加入 git 版本控制，若電腦還沒安裝git的話，可以先到<a href="https://git-scm.com/">git官網</a>下載git並安裝。</p>
<p>安裝好git後，在commend line輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init // 建立本地儲存庫</span><br><span class="line">git add . // 加入所有檔案到目錄</span><br><span class="line">git commit -m &quot;first commit&quot;  // 提交本次紀錄</span><br></pre></td></tr></table></figure>

<h2 id="新增-gitignore-檔案"><a href="#新增-gitignore-檔案" class="headerlink" title="新增 gitignore 檔案"></a>新增 gitignore 檔案</h2><p>因為有一些檔案是不需要加入版本控制的，如 public資料夾、.temp資料夾、node_modules資料夾，此時可以開一個 .gitignore 檔案，將不須控制的檔案忽略。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*6er_v_0LzoqbD_Pl0lTEgw.png" alt="gitignore"></p>
<p>在用 git status 去檢查未加入目錄的檔案時，就會發現有加入.gitignore的檔案都消失了，代表這些檔案不用被git做控制。</p>
<h2 id="快速發佈到-github-pages"><a href="#快速發佈到-github-pages" class="headerlink" title="快速發佈到 github pages"></a>快速發佈到 github pages</h2><p>在完成我們的gulp專案後，可以發佈到 github pages上。</p>
<p>先下載 <code>gulp-gh-pages</code>  套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install - save-dev gulp-gh-pages</span><br></pre></td></tr></table></figure>

<p>在gulpfile.js中加入deploy任務，因為有使用gulp-load-plugins這個套件，只要在ghPages()前方加入$即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deploy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./public/**/*&#x27;</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">ghPages</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸入 gulp deploy後，會在github上新開一個 gh-pages 的分支，自動將public資料夾裡的內容上傳到github。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*5FV7yd4cKZ0mp4dL-Y1-Dw.png" alt="github"></p>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>(12) Gulp-ejs</title>
    <url>/2022/06/18/2022-6-18-4-Gulp-ejs/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們在開發一個多頁式網站時，常常會有許多重複的區塊，例如表頭與表尾，可以將這些重複的區塊抽離出來，作為layout。此時就需要用到樣板語言來達成，來替 HTML 語言加入條件判斷、for 迴圈、元件化、套用模板等等功能。<br>本篇會介紹如何在gulp中，加入ejs樣板語言，幫助我們將重複的區塊抽離。</p>
<h2 id="套件安裝"><a href="#套件安裝" class="headerlink" title="套件安裝"></a>套件安裝</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install ejs --save   //安裝ejs</span><br><span class="line">npm install gulp-front-matter --save  // 幫每頁 HTML 個別設定變數</span><br><span class="line">npm install gulp-layout --save  // 以先接收 front-matter 傳來的值，然後傳到 EJS 模板接收變數，再轉成 HTML</span><br></pre></td></tr></table></figure>

<h2 id="ejs-任務建立"><a href="#ejs-任務建立" class="headerlink" title="ejs 任務建立"></a>ejs 任務建立</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ejs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(path.<span class="property">html</span>.<span class="property">src</span>)</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">plumber</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">frontMatter</span>())</span><br><span class="line">    .<span class="title function_">pipe</span>(</span><br><span class="line">      $.<span class="title function_">layout</span>(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> file.<span class="property">frontMatter</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .<span class="title function_">pipe</span>($.<span class="title function_">if</span>(options.<span class="property">env</span> === <span class="string">&#x27;prod&#x27;</span>, $.<span class="title function_">htmlmin</span>(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;)))</span><br><span class="line">    .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">    .<span class="title function_">pipe</span>(browserSync.<span class="title function_">stream</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="資料夾結構"><a href="#資料夾結構" class="headerlink" title="資料夾結構"></a>資料夾結構</h2><p><img src="https://cdn-images-1.medium.com/max/1320/1*3cxas_T2MN-W3YIgg9v5aQ.png" alt="folder"></p>
<p>在source裡建立一個layout.ejs檔案，裡頭可放表頭表尾等每一頁都會出現的區塊。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*XO6XwQGH-rn7AG2R3g9OsA.png" alt="layout"></p>
<p>在html裡，因為每個頁面會想客製化設定一些資訊，所以會在每個有使用到 EJS 模板的 HTML 檔的上方放上 front-matter。以首頁為例，front-matter 有著這些資訊：</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*Oo079oe6jMdMI5VqfJyrTg.png" alt="front-matter"></p>
<p>因此，ejs就可以取用 title變數取得首頁的值，並用layout變數指定layout的ejs檔。<br>整個運作過程大概是這樣：</p>
<ol>
<li>目錄下有具有 front-matter 的html檔、還有ejs 模板的 EJS 檔案</li>
<li>gulp-front-matter 套件會解析檔案中的 front-matter 部份，並轉成 JS object</li>
<li>gulp-layout 接收 JS object，把它跟 ejs 模板摻摻在一起，產出瀏覽器看得懂的 HTML 檔</li>
</ol>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
        <tag>ejs</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) SCSS練功坊-基礎介紹</title>
    <url>/2022/06/18/2022-6-18-5-scss-intro/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>scss屬於css的預處理器，他加入了程式語言所用的變數、迴圈、模組化等概念，讓我們更方便管理css。<br>現今較為主流的 CSS 預處理器有三種，分別是 Sass&#x2F;SCSS、Less、Stylus，其中的 Sass&#x2F;SCSS 是目前較多人使用的選擇。</p>
<h2 id="scss-語法介紹"><a href="#scss-語法介紹" class="headerlink" title="scss 語法介紹"></a>scss 語法介紹</h2><h3 id="巢狀寫法（Nesting）"><a href="#巢狀寫法（Nesting）" class="headerlink" title="巢狀寫法（Nesting）"></a>巢狀寫法（Nesting）</h3><p>以往寫css時，為了選取到某個元素底下的標籤，我們可能會重複選取該元素許多次，例如:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程式碼中，我們重複寫了 .card 3次。</p>
<p>在scss中我們可以用巢狀的寫法來減少重複的code，並且當父元素的class更改時，也只需要改一次即可:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>scss的功能除了上述介紹的巢狀語法以外，還有許多如變數、函式、mixin、模組化等概念會在之後等章節來介紹喔。</p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(4) SCSS練功坊-import</title>
    <url>/2022/06/19/2022-6-19-3-scss-import/</url>
    <content><![CDATA[<h2 id="模組化管理"><a href="#模組化管理" class="headerlink" title="模組化管理"></a>模組化管理</h2><p>以往寫css時，所有的code都寫在同一份css檔案裡，當code越來越多，就越難維護與管理你的css。<br>在scss裡，我們可以將檔案進行模組化管理，方法如下:</p>
<p>我們會有一個主要的scss檔案，在這個 scss 檔裡我們會import其他模組的scss檔進來，只有這個主要的scss檔案最後會被編譯成css。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061901.png?alt=media&token=baae5c4a-b4de-4b55-a04f-9681653bf7d1" alt="all.scss"></p>
<p>至於其他被引入的scss，我們會在檔案名稱前加上 「 _ 」 ，如「_reset.scss」， 加了 _ 的檔案就不會被編譯成 css。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022061902.png?alt=media&token=61fab007-d152-47c8-ae03-ce4a073e3391" alt="module"></p>
<h2 id="引入順序"><a href="#引入順序" class="headerlink" title="引入順序"></a>引入順序</h2><p>通常我們會有一個 all.scss ，裡面放其他要載入的SCSS檔。</p>
<p>這個檔案就會有一堆 @import，編譯出來的CSS檔案就會依照@import的前後排列來依序產生CSS碼。</p>
<ol>
<li><p>@import最前面的檔案裏面一定都會先放全域變數、mixin、function等，這樣後面的檔案 才吃的到變數的設定。</p>
</li>
<li><p>再來是 reset、base等全站共用的樣式。</p>
</li>
<li><p>layout可以網頁版型的共通設計，如表頭、表尾。</p>
</li>
<li><p>再來就index首頁、page內頁，再來就看你的單元數量視情況來切割。</p>
</li>
</ol>
<p>引入參考順序</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// variables</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./abstract/functions&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./abstract/variables&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./abstract/media-query&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base classes</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./base/reset&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./base/base&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./base/typography&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// utils</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./utils/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//layout</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./layout/grid&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pages</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./pages/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//components</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./components/button&#x27;</span>;</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(3) SCSS練功坊-計算功能</title>
    <url>/2022/06/19/2022-6-19-2-scss-calc/</url>
    <content><![CDATA[<h2 id="計算功能"><a href="#計算功能" class="headerlink" title="計算功能"></a>計算功能</h2><p>在 SCSS裡，我們可以用變數來做加減乘除等運算，如下我設定了 $font-size: 16px，之後再利用這個變數做運算，計算出其他font-size大小。但要注意計算時單位必須一樣。</p>
<p><img src="https://miro.medium.com/max/1028/1*n0VDI1urUorAt3oPPs4YXA.png" alt="font-size"></p>
<p>計算單位 除了px單位外，em與%數也可以，但假使你用px+em與%單位的話，會跳錯誤，因為單位不同。</p>
<h2 id="範例-計算container-寬度"><a href="#範例-計算container-寬度" class="headerlink" title="範例: 計算container 寬度"></a>範例: 計算container 寬度</h2><p>有一個 container 寬度為 $width :920px；裡面有6個子元素box，利用 width &#x2F; 6 ，直接算出每個box寬度。</p>
<p><img src="https://miro.medium.com/max/842/1*EzxbD-ztoCWUm-wqE3OVLA.png" alt="container"></p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(6) SCSS練功坊-extend</title>
    <url>/2022/06/19/2022-6-19-5-scss-extend/</url>
    <content><![CDATA[<h2 id="合併樣式"><a href="#合併樣式" class="headerlink" title="合併樣式"></a>合併樣式</h2><p>當我們有一段樣式常常用到，可以用@extend來將樣式合併在一起。</p>
<p>使用 % +class 撰寫要合併之樣式，並用@extend 來載入樣式。</p>
<p><img src="https://miro.medium.com/max/1220/1*E5-ebZ9tVXeHmwf4i4uN2w.png" alt="extend"></p>
<p><img src="https://miro.medium.com/max/1134/1*gUgESgMLa1DmyLz94Rp9Rw.png" alt="編譯後"></p>
<h2 id="Mixin與extend的使用時機"><a href="#Mixin與extend的使用時機" class="headerlink" title="Mixin與extend的使用時機"></a>Mixin與extend的使用時機</h2><p>基本上來說，<br>@mixin是將程式碼帶入到對應的class去，同時可帶入變數。<br>@extend則是藉由class合併，並吃到共通樣式，但沒辦法帶入變數。</p>
<p>所以如果你的樣式都固定不變的，不會需要用參數帶進去改變樣式的話，<br>那就用@extend，程式碼會比較少些。</p>
<p>但如果你的程式碼需要帶入多個變數進行運算時，<br>那用@mixin則較適合。</p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(7) SCSS練功坊-顏色函數</title>
    <url>/2022/06/20/2022-6-20-1-scss-color/</url>
    <content><![CDATA[<h2 id="顏色函數"><a href="#顏色函數" class="headerlink" title="顏色函數"></a>顏色函數</h2><p><img src="https://miro.medium.com/max/1400/1*SFb0wzFGrTw4byZVEbn_8g.png" alt="color"></p>
<p>在SCSS中 ，可以利用一些內建的函數，來調整顏色。</p>
<p>如: darken(#fff, 20%) &#x2F;&#x2F;將白色調暗10%；</p>
<p>lighten(#000,30% ) &#x2F;&#x2F;將黑色調亮10%;</p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(2) SCSS練功坊-變數variable</title>
    <url>/2022/06/19/2022-6-19-1-scss-variable/</url>
    <content><![CDATA[<h2 id="以往css遇到的問題"><a href="#以往css遇到的問題" class="headerlink" title="以往css遇到的問題"></a>以往css遇到的問題</h2><p>以往在寫css時，可能我們會直接將顏色的值寫死，例如:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f0a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f0a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣做的問題是，當今天客戶想將某個顏色替換時，我們必須手動一個一個更改，假如網站有300個地方用到該顏色，就需要手動改300次。</p>
<p>在 SCSS裡，我們可以使用變數來管理重複的值，例如 我們可以將色碼設定為變數，當後續需要調整顏色時，只要調整變數，就改完全站的設定。</p>
<h2 id="變數設定方式"><a href="#變數設定方式" class="headerlink" title="變數設定方式"></a>變數設定方式</h2><p>首先先在程式碼最上面打個『$』字號，後面則是自己命名的變數，之後在填上變數的值。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$color-primary</span>: <span class="number">#fa0</span>;</span><br><span class="line"><span class="variable">$color-gray</span>: <span class="number">#aaa</span>;</span><br></pre></td></tr></table></figure>

<p>之後需要設定顏色樣式時，就可以引入變數。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$color-primary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>變數除了支援色碼外還支援「字串」、「數字」等等。</p>
<p>雙引號的字串也可用 #{ }取出來:</p>
<p><img src="https://miro.medium.com/max/1004/1*jvZyuT0ob0GIxXyu3fdjoQ.png" alt="va"></p>
<p><img src="https://miro.medium.com/max/1048/1*ZgC18gRiXbzEUl_FiZrwuQ.png" alt="編譯後"></p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>學會使用變數以後，就不用辛苦的一個一個修改css了，全站的設定統一由變數管理，讓之後的修改與維護更輕鬆。</p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(8) SCSS練功坊-Each loops</title>
    <url>/2022/06/20/2022-6-20-2-scss-loop/</url>
    <content><![CDATA[<h2 id="建立陣列"><a href="#建立陣列" class="headerlink" title="建立陣列"></a>建立陣列</h2><p>在scss中，可以使用each loop快速產生樣式。</p>
<p>首先，可以建立一個陣列如下:</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  <span class="string">&#x27;primary&#x27;</span>:   <span class="number">#326dee</span>,</span><br><span class="line">  <span class="string">&#x27;secondary&#x27;</span>: <span class="number">#1ac886</span>,</span><br><span class="line">  <span class="string">&#x27;danger&#x27;</span>:    <span class="number">#d32752</span>,</span><br><span class="line">  <span class="string">&#x27;light&#x27;</span>:     <span class="number">#c2c2c2</span>,</span><br><span class="line">  <span class="string">&#x27;dark&#x27;</span>:      <span class="number">#000</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>陣列中會有key跟value，利用 @each 迴圈的方式產生樣式</p>
<p><img src="https://miro.medium.com/max/846/1*3n3L745sBINDgCmWKUQMmw.png" alt="loop"></p>
<p>其中 $name 跟 $color 分別代表 陣列裡的key跟value，利用 # { }將參數$name一一帶入後，就可以產生各個樣式。</p>
<h2 id="陣列寫法注意事項"><a href="#陣列寫法注意事項" class="headerlink" title="陣列寫法注意事項"></a>陣列寫法注意事項</h2><p><img src="https://miro.medium.com/max/810/1*4Jkss8qZjal6t_qG1s2qFw.png" alt="loop"></p>
<ol>
<li>key如果是string要加上 ‘ ‘</li>
<li>每個key和value都是獨立一行</li>
<li>最後一行，也建議加上 , 方便閱讀</li>
</ol>
<h2 id="陣列多個值"><a href="#陣列多個值" class="headerlink" title="陣列多個值"></a>陣列多個值</h2><p>一個scss陣列也可以有多組值</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$heading-list</span>: (</span><br><span class="line">  h1   <span class="number">50px</span>   <span class="number">300</span>,</span><br><span class="line">  h2   <span class="number">42px</span>   <span class="number">300</span>,</span><br><span class="line">  h3   <span class="number">34px</span>   <span class="number">400</span>,</span><br><span class="line">  h4   <span class="number">26px</span>   <span class="number">400</span>,</span><br><span class="line">  h5   <span class="number">20px</span>   <span class="number">600</span>,</span><br><span class="line">  h6   <span class="number">16px</span>   <span class="number">600</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$value</span> in <span class="variable">$heading-list</span> &#123;</span><br><span class="line">  #&#123;<span class="built_in">nth</span>($value, <span class="number">1</span>)&#125;,</span><br><span class="line">  <span class="selector-class">.txt-</span>#&#123;<span class="built_in">nth</span>($value, <span class="number">1</span>)&#125; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: nth(<span class="variable">$value</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>: nth(<span class="variable">$value</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以產生如下的css</p>
<p><img src="https://miro.medium.com/max/920/1*TsqyJQQt3ZDwIrzVK0MWTQ.png" alt="img"></p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(5) SCSS練功坊-mixin</title>
    <url>/2022/06/19/2022-6-19-4-scss-mixin/</url>
    <content><![CDATA[<h2 id="使用-mixin-管理重複的樣式"><a href="#使用-mixin-管理重複的樣式" class="headerlink" title="使用 mixin 管理重複的樣式"></a>使用 mixin 管理重複的樣式</h2><p>當我們有一段樣式，會被重複用到，裡頭樣式數值又會有不同時，可以用mixin做管理。<br>撰寫mixin方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin + mixin名稱(參數) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1266/1*M5IXbD8WVeMwgzfadFHNrQ.png" alt="circle"></p>
<p>上圖中， circle 裡可以帶入 $size，$bg-color等不同參數，如此在不同地方，我們可以依照不同需求，傳入不同參數，做出不同的圓形。</p>
<p>引入 mixin時，用 @include + mixin名稱</p>
<p><img src="https://miro.medium.com/max/1140/1*Yn5snpWqUCxsEJ1eA646zQ.png" alt="編譯後結果"></p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) CSS 響應式設計-文字大小</title>
    <url>/2022/06/20/2022-6-20-4-rwd-text/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當我們設計一個響應式的網站時，除了版面隨著裝置大小不同，文字大小也會不同。例如手機板的文字應該就要比桌機版的文字來的小。這章節就介紹一些設定響應式文字的方法。</p>
<h2 id="Media-query"><a href="#Media-query" class="headerlink" title="Media-query"></a>Media-query</h2><p>使用media-query來設定不同裝置的文字大小，算是最常用的手法。<br>本系列範例皆以 scss 的寫法呈現。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">960px</span>) &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VW"><a href="#VW" class="headerlink" title="VW"></a>VW</h2><p>使用vw這個單位來設計，會隨著網頁縮放而改變尺寸，每1vw代表螢幕寬度的 1%。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: calc(<span class="number">16px</span> + <span class="number">2vw</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我們用了 calc 語法，將16px + 2vw 作為文字大小。這樣做確保我們的文字最小是 16px，並且隨著螢幕越大，2vw的值也會越大，讓文字能隨螢幕縮放。</p>
<h2 id="clamp"><a href="#clamp" class="headerlink" title="clamp"></a>clamp</h2><p>使用 clamp 語法來設計，clamp可以傳入三個值，讓我們設定最大和最小的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clamp(最小的值，我們希望的值，最大的值)</span><br></pre></td></tr></table></figure>

<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: clamp(<span class="number">1.375rem</span>, <span class="number">0.875rem</span> + <span class="number">2vw</span>, <span class="number">2.25rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://youtu.be/jfMHA8SqUL4?t=7595">參考教學影片</a></p>
<h2 id="響應式文字的單位"><a href="#響應式文字的單位" class="headerlink" title="響應式文字的單位"></a>響應式文字的單位</h2><p>關於響應式文字的單位，盡量使用相對單位 rem 來設計。如果使用px這種絕對單位設計，會讓使用者無法在瀏覽器的設定中調整文字大小。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022062001.png?alt=media&token=c30147dd-d0b8-486b-be92-d972de794d77" alt="瀏覽器設定文字大小"></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>RWD</tag>
      </tags>
  </entry>
  <entry>
    <title>(9) SCSS練功坊-7+1資料夾規劃</title>
    <url>/2022/06/20/2022-6-20-3-scss-7-1/</url>
    <content><![CDATA[<h2 id="7-1-資料夾規劃"><a href="#7-1-資料夾規劃" class="headerlink" title="7 + 1 資料夾規劃"></a>7 + 1 資料夾規劃</h2><p>當我們有許多SCSS檔案要規劃時，可以使用7+1歸納法，也就是7個資料夾搭配 1個 all.scss檔案</p>
<p><img src="https://miro.medium.com/max/1128/1*jmb4MvIeinaRy7etvwvhZw.png" alt="img"></p>
<h3 id="abstract-資料夾"><a href="#abstract-資料夾" class="headerlink" title="abstract 資料夾"></a>abstract 資料夾</h3><p>放 variables、mixin、funtion等不會真正產出 css 的 scss 檔案</p>
<h3 id="base-資料夾"><a href="#base-資料夾" class="headerlink" title="base 資料夾"></a>base 資料夾</h3><p>放 base.scss 、 reset.scss、Typography等全域設定的scss</p>
<h3 id="components-資料夾"><a href="#components-資料夾" class="headerlink" title="components 資料夾"></a>components 資料夾</h3><p>放全站都會用到的元件，如 button 、 label、nav等等</p>
<h3 id="layout-資料夾"><a href="#layout-資料夾" class="headerlink" title="layout 資料夾"></a>layout 資料夾</h3><p>放全站共用的layout區塊，如 grid 、header、footer等等</p>
<h3 id="pages-資料夾"><a href="#pages-資料夾" class="headerlink" title="pages 資料夾"></a>pages 資料夾</h3><p>放 每頁不同的scss</p>
<h3 id="themes資料夾"><a href="#themes資料夾" class="headerlink" title="themes資料夾"></a>themes資料夾</h3><p>如果你的網站有主題樣式，可以放這裡</p>
<h3 id="vendor-資料夾"><a href="#vendor-資料夾" class="headerlink" title="vendor 資料夾"></a>vendor 資料夾</h3><p>放外部資源的scss檔，如bootstrap.scss</p>
<p>另外可參考<a href="https://gist.github.com/rveitch/84cea9650092119527bc">此網站配置</a></p>
]]></content>
      <categories>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) CSS 基礎篇-Position</title>
    <url>/2022/06/21/2022-6-21-1-css-posotion/</url>
    <content><![CDATA[<h2 id="Position-屬性介紹"><a href="#Position-屬性介紹" class="headerlink" title="Position 屬性介紹"></a>Position 屬性介紹</h2><p>在網頁中 position 的用途是設定「物件定位時所要的參考對像」，預設狀態下物件的位置是依據資料流來做排列，也就是跟隨資料做排列，如果對物件添加了不同的 position 之後，就能改變物件所參考的空間對像，進而改變物件的位置。</p>
<p>以下分別介紹各種position 屬性</p>
<h2 id="static-靜態定位"><a href="#static-靜態定位" class="headerlink" title="static 靜態定位"></a>static 靜態定位</h2><p>是元素的預設值，不會被特別定位」在頁面上特定位置，而是照著瀏覽器預設的配置自動排版在頁面上</p>
<h2 id="relative-相對定位"><a href="#relative-相對定位" class="headerlink" title="relative 相對定位"></a>relative 相對定位</h2><p>在一個設定為 position: relative 的元素內設定 top 、 right 、 bottom 和 left 屬性，會使其元素「相對地」調整其原本該出現的所在位置，而不管這些「相對定位」過的元素如何在頁面上移動位置或增加了多少空間，都不會影響到原本其他元素所在的位置。可以稱為【偏移顯示】</p>
<p>不過通常不會對position relative設定top 、 right 等位移，因為會讓元素脫離預設的排版，讓我們很難去設定周圍元素的樣式。</p>
<p><a href="https://youtu.be/jx5jmI0UlXU?t=166">參考影片</a></p>
<h2 id="abosulute-絕對定位"><a href="#abosulute-絕對定位" class="headerlink" title="abosulute 絕對定位"></a>abosulute 絕對定位</h2><p>會將元素從預設排版中抽離，就像不存在於html結構中一樣。<br>元素設定 Position abosulute 後會去尋找父層中，有定位的元素做定位，如最常用的 position:relative、或fixed、absolute；<br>若父層都沒有定位元素，就會跟瀏覽器做定位。</p>
<p>position absolute可以搭配top 、bottom 、right、left 來設定定位位置，如下面範例將元素定位在左上角。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: position;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="absolute搭配-width-height技巧"><a href="#absolute搭配-width-height技巧" class="headerlink" title="absolute搭配 width height技巧"></a>absolute搭配 width height技巧</h3><p>width、height、margin: auto 跟top 、bottom等一起用，可以控制元素的大小與位置，<a href="https://www.youtube.com/watch?v=QGKO0PGzFXQ&t=16s">教學影片</a></p>
<p><img src="https://miro.medium.com/max/826/1*ThNCveqMOYrXF4nVoTBWkw.png" alt="position"></p>
<p><img src="https://miro.medium.com/max/1400/1*PIKeD9RV4TGRvLhT3w5ylA.png" alt="position"></p>
<h2 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed 固定定位"></a>fixed 固定定位</h2><p>固定定位（position: fixed）的元素會相對於瀏覽器視窗來定位，這意味著即便頁面捲動，它還是會固定在相同的位置。和 relative 一樣，我們會使用 top 、 right 、 bottom 和 left 屬性來定位。</p>
<p>固定定位元素不會保留它原本在頁面應有的空間，不會跟其他元素的配置互相干擾。</p>
<h2 id="sticky-黏著定位"><a href="#sticky-黏著定位" class="headerlink" title="sticky 黏著定位"></a>sticky 黏著定位</h2><p>結合了 position : relative，跟 position: fixed，當使用者沒滑動卷軸時，就跟relative元素一樣，當使用者滑動卷軸時，則跟position: fixed 會固定在視窗上。</p>
<p><a href="https://codepen.io/tim-chou/pen/NWbvMQL">範例</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS基礎篇</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) Git 練功坊-安裝教學</title>
    <url>/2022/06/21/2022-6-21-3-git-install/</url>
    <content><![CDATA[<h2 id="什麼是git"><a href="#什麼是git" class="headerlink" title="什麼是git"></a>什麼是git</h2><p>以往在做檔案版本的管理時，最簡單的方法就是複製編輯前的檔案並在檔案名稱加上日期，但是，每次編輯檔案都要複製非常的麻煩，也很容易出錯。</p>
<p>Git為分散式版本控制系統，可以把檔案的狀態作為更新歷史記錄保存起來。因此可以把編輯過的檔案復原到以前的狀態，也可以顯示編輯過內容的差異。</p>
<p>本系列文章為參考 <a href="https://courses.hexschool.com/p/git-github">六角學院git課程</a> 紀錄。</p>
<h2 id="安裝git"><a href="#安裝git" class="headerlink" title="安裝git"></a>安裝git</h2><p><img src="https://miro.medium.com/max/1400/1*9tfhhWJLGL5HM7V99xkKXw.png" alt="git官網"></p>
<p>先到 <a href="https://git-scm.com/">git官網</a> 下載git</p>
<h2 id="確認git版本"><a href="#確認git版本" class="headerlink" title="確認git版本"></a>確認git版本</h2><p>在VScode編輯器裡，按 ctrl + ~ 開啟終端機畫面。<br>輸入 <code>git version</code> 確認下載的git版本，若有出現版本號，就安裝成功囉。</p>
<p><img src="https://miro.medium.com/max/1138/1*Q48Ug1afDJ2JzugYH_fslA.png" alt="git版本"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>(2) CSS 基礎篇-background-image</title>
    <url>/2022/06/21/2022-6-21-2-css-bg/</url>
    <content><![CDATA[<h2 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h2><p>background-image 可以設定一張或多張的圖片，寫法如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;tim.png&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背景圖片的設定，在不控制大小的情況下，預設就是原始圖片大小，且圖片僅會顯示在區塊的範圍內，也就是說當圖片太大張的時候，圖片將會發生裁切的情形。另外，當同時設定了background-color與background-image的時候，background-image將會蓋住background-color。</p>
<p>background-image支援的值有以下幾種</p>
<ul>
<li>url( )</li>
<li>linear-gradient( )</li>
<li>radial-gradient( )</li>
<li>repeating-linear-gradient( )</li>
<li>repeating-radial-gradient()</li>
<li>Inital</li>
<li>Inherit</li>
</ul>
<h2 id="url-設定"><a href="#url-設定" class="headerlink" title="url() 設定"></a>url() 設定</h2><p>url所要撰寫的是圖片檔案所在的位置，可使用</p>
<ul>
<li><p>相對路徑: (“..&#x2F;pic&#x2F;01.jpg”);</p>
</li>
<li><p>絕對路徑: (“<a href="https://medium.com/&quot;">https://medium.com/&quot;</a>);</p>
</li>
</ul>
<h2 id="多重背景功能"><a href="#多重背景功能" class="headerlink" title="多重背景功能"></a>多重背景功能</h2><p><img src="https://miro.medium.com/max/1336/1*hj-Xjk2RizivLb7zWblx3Q.png" alt="多重背景"></p>
<p>可以寫入多張背景圖的url，並在每個url之間使用了逗號做區隔，要注意</p>
<ol>
<li>背景圖片的堆疊是按照順序的，先寫的則顯示在前，後寫的顯示在後，依序堆疊</li>
<li>背景圖片設定不要重複(background-repeat: no-repeat;)</li>
<li>背景圖片的位置設定要錯開(position)</li>
</ol>
<h2 id="漸層背景設定"><a href="#漸層背景設定" class="headerlink" title="漸層背景設定"></a>漸層背景設定</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-image: linear-gradient(起始色彩, 結束色彩);</span><br></pre></td></tr></table></figure>

<p>指定方向漸層</p>
<p><img src="https://miro.medium.com/max/1374/1*yBOyNTlobUkGFw_qt1a4Yg.png" alt="漸層設定"></p>
<ul>
<li>to top (下方漸層到上方)</li>
<li>to right (左方漸層到右方)</li>
<li>to bottom (上方漸層到下方)</li>
<li>to left (右方漸層到左方)</li>
<li>to top left (右下漸層到左上)</li>
<li>to top right (左下漸層到右上)</li>
<li>to bottom right (左上漸層到右下)</li>
<li>to bottom left (右上漸層到左下)</li>
</ul>
<p><img src="https://miro.medium.com/max/1114/1*qsdu8QDqQ-SRelX0DySwLw.png" alt="漸層設定"></p>
<p>或直接寫(60deg,起始顏色，結束顏色)</p>
<h2 id="背景重複設定"><a href="#背景重複設定" class="headerlink" title="背景重複設定"></a>背景重複設定</h2><ol>
<li>background-repeat: no-repeat</li>
<li>background-repeat: repeat-x (水平方向位移)</li>
<li>background-repeat: repeat-y(垂直方向位移)</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS基礎篇</tag>
      </tags>
  </entry>
  <entry>
    <title>(3) Git 練功坊-紀錄修改與提交</title>
    <url>/2022/06/21/2022-6-21-5-git-commit/</url>
    <content><![CDATA[<p><img src="https://miro.medium.com/max/1400/0*adRfjDwIz9wuzSTb" alt="git流程"></p>
<h2 id="新增資料並加入索引"><a href="#新增資料並加入索引" class="headerlink" title="新增資料並加入索引"></a>新增資料並加入索引</h2><p>上一章節已經將專案的數據庫建立好了，那我們先在專案內新增一些資料，我先建立一個 「sample.txt」的文字檔案，並在裡面打一些內容。</p>
<p>此時我們可以將新增的資料加入索引，加入索引的檔案之後才能被commit 提交，方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .    // 將所有更新的檔案加入索引。</span><br><span class="line">git add 檔案名稱  // 將特定檔案加入索引。</span><br></pre></td></tr></table></figure>

<h2 id="查詢檔案狀況"><a href="#查詢檔案狀況" class="headerlink" title="查詢檔案狀況"></a>查詢檔案狀況</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status  // 查詢目前檔案狀況</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1268/1*0-Hunc2dByNVE3AeTQPTyQ.png" alt="git status"></p>
<p>上圖中綠色是已加入索引，紅色是未加入。</p>
<p>若要取消加入索引，可用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset HEAD   // 取消已加入索引的全部檔案，此時檔案會呈現未追蹤狀態。</span><br><span class="line">git reset HEAD 檔案名稱   // 取消已加入索引的單個檔案，呈現未追蹤狀態。</span><br></pre></td></tr></table></figure>

<h2 id="提交檔案"><a href="#提交檔案" class="headerlink" title="提交檔案"></a>提交檔案</h2><p>若確認檔案都加入索引後，可以將索引內的檔案提交到數據庫</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;更新內容&quot;</span><br></pre></td></tr></table></figure>

<p>我們使用 git commit 將本次的更新提交到數據庫，-m 可以輸入更新的內容重點。<br>通常我們會在專案開發完某個功能後，做一次commit。例如完成首頁輪播功能，或切完首頁版型等等，方便之後做版本切換。</p>
<p><img src="https://miro.medium.com/max/1400/1*rM-6FClWTQvcFPXmYmq8JQ.png" alt="commit"></p>
<h2 id="查詢紀錄"><a href="#查詢紀錄" class="headerlink" title="查詢紀錄"></a>查詢紀錄</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log  // 查詢過去commit 的紀錄</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*qNvdGY6XePWNMA3h4a--LQ.png" alt="git log"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>(2) Git 練功坊-數據庫</title>
    <url>/2022/06/21/2022-6-21-4-git-basic/</url>
    <content><![CDATA[<h2 id="使用數據庫管理歷史記錄"><a href="#使用數據庫管理歷史記錄" class="headerlink" title="使用數據庫管理歷史記錄"></a>使用數據庫管理歷史記錄</h2><p>數據庫 (Repository) 是git用來記錄檔案或目錄狀態的地方，儲存內容的修改歷史記錄。數據庫可分為兩種</p>
<ul>
<li>遠端數據庫 : 配有專用的伺服器，為了讓多人共享而建立的數據庫。</li>
<li>本地端數據庫 : 在本機專案上建立的數據庫。</li>
</ul>
<p>在本地端更新好檔案後，我們可以用push等方法將本地端的資料上傳到遠端數據庫。<br>遠端數據庫的資料有更新時，也可下載更新到本地端。</p>
<h2 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h2><p>如果是第一次用git，需要先輸入姓名和電子信箱的資料</p>
<p>在終端機輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config — global user.email “ 電子信箱“</span><br><span class="line"></span><br><span class="line">git config — global user.name ”名字”</span><br></pre></td></tr></table></figure>

<p>方便之後再做版本控制時，可以知道是誰修改檔案。</p>
<h2 id="建立本地端數據庫"><a href="#建立本地端數據庫" class="headerlink" title="建立本地端數據庫"></a>建立本地端數據庫</h2><p>先新開一個專案資料夾並移動進去，先新增一個本地端數據庫<br>在終端機輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init  // 新增本地數據庫</span><br></pre></td></tr></table></figure>

<p>新增完成後，會出現master字樣，代表新增成功囉。</p>
<p><img src="https://miro.medium.com/max/1354/1*e-Nug4-xJBAoymsYYN91TQ.png" alt="git數據庫"></p>
<p>數據庫建立好後，下一章節會介紹git基礎語法喔。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>(4) Git 練功坊-遠端數據庫</title>
    <url>/2022/06/21/2022-6-21-6-git-remote/</url>
    <content><![CDATA[<h2 id="遠端數據庫"><a href="#遠端數據庫" class="headerlink" title="遠端數據庫"></a>遠端數據庫</h2><p>之前介紹過如何再本地端提交更新，今天要教大家將本地端的更新提交到遠端數據庫(Github)。</p>
<h2 id="註冊Github"><a href="#註冊Github" class="headerlink" title="註冊Github"></a>註冊Github</h2><p>我們要先去 <a href="https://github.com/">GitHub</a> 註冊會員。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20190908/20119923T2oDPSuQK3.png" alt="github"></p>
<h2 id="新建一個-repository"><a href="#新建一個-repository" class="headerlink" title="新建一個 repository"></a>新建一個 repository</h2><p>註冊好帳號後，可以在github上新建一個 repository 數據庫</p>
<p><img src="https://miro.medium.com/max/1400/1*7xMLMI0zZ87X4s9Hi4EIHg.png" alt="repository"></p>
<p>這邊填寫數據庫名稱</p>
<p><img src="https://miro.medium.com/max/1400/1*PdIfUXuiD4hS1HDjNyhU7w.png" alt="repo-name"></p>
<h2 id="複製遠端數據庫到本地端"><a href="#複製遠端數據庫到本地端" class="headerlink" title="複製遠端數據庫到本地端"></a>複製遠端數據庫到本地端</h2><p>新開一個專案資料夾並移動進去</p>
<p>輸入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone 遠端數據庫網址</span><br></pre></td></tr></table></figure>

<p>輸入完後，會將遠端新增的repository複製到本地資料夾內。</p>
<p><img src="https://miro.medium.com/max/1400/1*TRv6Lzld1DosUcNDlJWErQ.png" alt="git-clone"></p>
<h2 id="推送資料到遠端數據庫"><a href="#推送資料到遠端數據庫" class="headerlink" title="推送資料到遠端數據庫"></a>推送資料到遠端數據庫</h2><p>在本地端新增資料，並照上個章節的做法 commit完以後，就可以將 commit 上傳到遠端資料夾內囉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push  // 將資料推到遠端</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*7mwBekzTKtNV_DHCBs_txg.png" alt="上傳成功"></p>
<h2 id="從遠端下載資料"><a href="#從遠端下載資料" class="headerlink" title="從遠端下載資料"></a>從遠端下載資料</h2><p>若遠端資料庫的資料有更新，比如說其他同事有push新的資料上去，那我們有兩種方式將資料下載下來。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull  // 從遠端拉取資料下來，並直接合併</span><br></pre></td></tr></table></figure>

<p>執行 git pull 會將遠端更新的資料下載下來，並且會直接合併。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch  // 從遠端拉取資料下來，但不合併</span><br></pre></td></tr></table></figure>

<p>執行 git fetch 也會從遠端下載資料下來，但不會直接合併，而是以新的commit呈現。<br>等確認這些新的commit內容ok，可以再自行用 git merge 合併進專案。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 let、const、var的區別</title>
    <url>/2022/06/21/2022-6-21-7-js-variables/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在es6以前，我們會用 var 來宣告一個變數。而在es6推出後，新增了 let 與 const的變數宣告方法，改善了使用 var 宣告變數的一些缺點，以下用講解 var 與 let const 宣告的差異。</p>
<h2 id="區塊與函式作用域"><a href="#區塊與函式作用域" class="headerlink" title="區塊與函式作用域"></a>區塊與函式作用域</h2><p>var是函式作用域的設計，在函式內宣告的變數，函式外讀取不到。<br>但在一些使用了區塊語句(用花括號的語句)的像if, else, for, while等等區塊語句中，在這裡面用var宣告的變數仍然是會曝露到全域之中可被存取，例如:</p>
<p><img src="https://miro.medium.com/max/1178/1*iO1BqGOT_318PIkF8jjxJQ.png" alt="函式作用域"></p>
<p>let或const來宣告是區塊作用域，就是以區塊語句 { } 為分界的作用域:</p>
<p>不管是在函式內宣告的變數，或是 在 if, else, for, while等等區塊語句{ }中宣告的變數，都不會在全域中被讀取到。</p>
<p><img src="https://miro.medium.com/max/964/1*1IltRn_k3xANnY6fWcZW1A.png" alt="區塊作用域"></p>
<h2 id="重複宣告的問題"><a href="#重複宣告的問題" class="headerlink" title="重複宣告的問題"></a>重複宣告的問題</h2><p>以往用 var 宣告變數，是可以進行重複宣告的: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>這樣可能會不小心複寫了變數的值，導致專案出錯。</p>
<p>用 const let 告的變數，在同一個作用域下，則無法重新再被宣告。</p>
<p><img src="https://miro.medium.com/max/440/1*06HErRPc-Jcyhazl3fuj7w.png" alt="const let"></p>
<p><img src="https://miro.medium.com/max/1286/1*zsSWcfXZBnj3Ap1D5JE7Pg.png" alt="error"></p>
<h2 id="常數"><a href="#常數" class="headerlink" title="常數"></a>常數</h2><p>const 針對是常數的定義，常數在一宣告時就必定要指定給值，不然會產生錯誤。而對於常數在ES6的定義是: 不可再指定。</p>
<p><img src="https://miro.medium.com/max/1278/1*lpOInYC-ccAVD_dBcv5csg.png" alt="const"></p>
<p>上面因為再次賦予 a &#x3D; 20 而出現錯誤。</p>
<p>如果你宣告的常數是一個物件或陣列類型，像這種參照類型的值，裡面的值是可以作改變的，如下:</p>
<p><img src="https://miro.medium.com/max/336/1*IP1XW0OtYFB_Am976yXjNA.png" alt="array"></p>
<p>所以對於物件、陣列、函式來說，使用 const 常數來宣告就可以，除非你有需要再指定這個陣列或物件的參照。</p>
<h2 id="Hoisting-向上提升特性"><a href="#Hoisting-向上提升特性" class="headerlink" title="Hoisting 向上提升特性"></a>Hoisting 向上提升特性</h2><p>var 跟 function 都有向上提升特性，在宣告後會自動提升到 js 最上面 ，縱使還沒賦予值，還是先建立好記憶體位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a =<span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如上面程式，我們在第 2 行宣告了 a 變數等於3，但在第一行就讀取a變數，此時並不會報錯，因為 a 已經有記憶體位置了，只是還沒給予值，所以會是 undefined。 在第3行讀取a變數就可以正確讀到 3 的值。</p>
<p>let 跟 const 沒有向上提升， 必須先宣告、後使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">// b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>(5) Git 練功坊-合併與衝突</title>
    <url>/2022/06/23/2022-6-23-1-git-conflict/</url>
    <content><![CDATA[<h2 id="合併與衝突"><a href="#合併與衝突" class="headerlink" title="合併與衝突"></a>合併與衝突</h2><p>上章節講過我們可以用 git pull 或 git fetch 來下載遠端更新的內容。<br>如果遠端數據庫和本地端數據庫的同一個地方都發生了修改的情況下（例：檔案中同一行的地方）。<br>這時，因為Git不能自動判斷要導入那一個修改內容於是就會發生錯誤。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是 Cat<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是 Dog<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dog</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此時發生衝突的地方必須手動修改，如上例，VScode會提醒你產生衝突的地方，此時再決定要留 cat 還是 dog。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>(7) Git 練功坊-分支合併與刪除</title>
    <url>/2022/06/23/2022-6-23-3-git-merge/</url>
    <content><![CDATA[<h2 id="分支合併-merge"><a href="#分支合併-merge" class="headerlink" title="分支合併 merge"></a>分支合併 merge</h2><p><img src="https://miro.medium.com/max/1080/1*fnd052WeDjGw8beojbdr9Q.png" alt="branch"></p>
<p>如上圖，當我們在新的分支(feature)做開發，同事也確認分支的內容沒問題，就可以準備將分支合併到上線版本的master上。</p>
<p>首先用 git chcekout master，將HEAD 切回 master分支上，輸入 git merge 分支名稱，將分支合併到master上。</p>
<p><img src="https://miro.medium.com/max/820/1*feA1uszhAzBRENRGEAD2zQ.png" alt="branch"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge 分支名稱</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/616/1*AAb6Xi_rtOs_Tq4Gq6gAUw.png" alt="git merge"></p>
<p><img src="https://miro.medium.com/max/968/1*Ov7_N-2e1vFkRriAJDLzcw.png" alt="git"></p>
<p>此時就完成合併了。</p>
<h2 id="分支合併-rebase"><a href="#分支合併-rebase" class="headerlink" title="分支合併 rebase"></a>分支合併 rebase</h2><p>除了使用merge合併外，也可用 rebase 合併</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*_pZko1Os8-4Jf-n769khKQ.png" alt="rebase"></p>
<p>目前有 cat、dog 以及 master 這三個分支，並且切換至 cat 分支上。這時候如果下這個指令：git rebase dog<br>這個指令翻成白話文，大概就是「我，就是 cat 分支，我現在要重新定義我的參考基準，並且將使用 dog 分支當做我新的參考基準」的意思。<br>完成之後，cat 分支將會接到 dog 分支上，像這樣：</p>
<ol>
<li><p>「我先拿 c68537 這個 Commit 接到 053fb2 這個 Commit 上」，因為 c68537 原本的上一層 Commit 是 e12d8e，現在要接到 053fb2 上，所以需要重新計算這個 Commit 的 SHA-1 值，重新做出一顆新的 Commit 物件 35bc96。</p>
</li>
<li><p>「我再拿 b174a5 這個 Commit 接到剛剛那個新做出來的 Commit 物件 35bc96 上」，同理，因為 b174a5 這顆 Commit 要接到新的 Commit 的原因，所以它也會重新計算 SHA-1 值，得到一個新的 Commit 物件 28a76d。</p>
</li>
<li><p>最後，原本的 cat 是指向 b174a5 這個 Commit，現在要改指向最後做出來的那顆新的 Commit 物件 28a76d。<br>HEAD 還是繼續指向 cat 分支。</p>
</li>
</ol>
<h3 id="rebase-衝突"><a href="#rebase-衝突" class="headerlink" title="rebase 衝突"></a>rebase 衝突</h3><p><img src="https://cdn-images-1.medium.com/max/1320/1*ZV1WbkVCN04Wz63k8tqH6g.png" alt="rebase-conflict"></p>
<p>當rebase發生衝突時，要先手動解決衝突，如上圖選擇要保留的檔案。<br>處理完衝突後，輸入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .  //加入索引</span><br><span class="line">git rebase --continue  // 完成rebase流程</span><br></pre></td></tr></table></figure>

<h2 id="刪除分支"><a href="#刪除分支" class="headerlink" title="刪除分支"></a>刪除分支</h2><p>既然feature分支的內容已經順利地合併到master分支了，現在我們可以將其刪除。</p>
<p>欲刪除分支，請執行branch -d 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;分支名稱&gt;</span><br></pre></td></tr></table></figure>

<p>執行 <code>git branch -d feature</code> 就可以將 feature 分支刪除囉。</p>
<p>feature分支被刪除了，可以用”git branch”命令來確認分支是否已被刪除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>(6) Git 練功坊-建立分支</title>
    <url>/2022/06/23/2022-6-23-2-git-branch/</url>
    <content><![CDATA[<h2 id="什麼是分支？"><a href="#什麼是分支？" class="headerlink" title="什麼是分支？"></a>什麼是分支？</h2><p>分支是為了將修改記錄的整體流程分開儲存，讓分開的分支不受其他分支的影響，所以在同一個數據庫裡可以同時進行多個不同的修改。</p>
<p>當我們輸入完 git init 後，並完成第一次提交後(commit)會自動產生一個 main 分支，在建立其他分支前，所有紀錄都存在main分支上。</p>
<h2 id="建立分支"><a href="#建立分支" class="headerlink" title="建立分支"></a>建立分支</h2><p>要建立一個新的分支，可以用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch 分支名稱</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1206/1*MM7zD5dXszOgNHn_UcqtOg.png" alt="branch"></p>
<p>要查詢目前有的分支可以輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1134/1*8p-_J_x4kqDFcnO15JBRLQ.png" alt="brach"></p>
<p>此時用git branch 去查詢，可以發現多了 feature1 分支，但目前所在分支還是master。</p>
<h2 id="切換分支"><a href="#切換分支" class="headerlink" title="切換分支"></a>切換分支</h2><p>假設目前有 master 分支和 feature1分支，我現在在master分支上，想切換到 feature1分支，可用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout 分支名稱</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1218/1*Gzf7OBa_JANOziPgnxYaVQ.png" alt="checkout"></p>
<h2 id="HEAD標籤"><a href="#HEAD標籤" class="headerlink" title="HEAD標籤"></a>HEAD標籤</h2><p>HEAD是目前所在位置的指標，會跟隨在最新的commit上面，如下圖:</p>
<p><img src="https://miro.medium.com/max/680/1*vBHV9Vo4Ws2O4a_AfGPdig.png" alt="head"></p>
<p>在git裡的每個commit都有自己的代碼，我們可以用 git log 查詢所有 commit 紀錄。</p>
<p><img src="https://miro.medium.com/max/1272/1*fcmwOhm5NG9_XpjeoFhPxw.png" alt="commit"></p>
<p>如果想看前一版本commit紀錄裡做了哪些事，可以透過指令將HEAD移動到該commit版本上，看完後再移動回最新的commit上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout commit前四碼</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/676/1*ItxAAKHhndN-_oToicuXnw.png" alt="checkout"></p>
<p>分支的切換其實也就是將HEAD移動到不同分支標籤上而已。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Js 中繪製動畫 requestAnimationFrame</title>
    <url>/2022/06/27/2022-6-24-1-js-requestAnimation/</url>
    <content><![CDATA[<h2 id="製作動畫"><a href="#製作動畫" class="headerlink" title="製作動畫"></a>製作動畫</h2><p>在以前用Js中做動畫，可能會用 setInterval()或setTimeOut()，而現在有了更好用的API <code>requestAnimationFrame</code>。</p>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>requestAnimationFrame是依照瀏覽器更新的頻率(通常是 1 &#x2F;60 秒)來更新畫面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boxLeft = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">currentTime</span>) &#123;</span><br><span class="line">  boxLeft += <span class="number">0.1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(currentTime);</span><br><span class="line">  box.<span class="property">style</span>.<span class="title function_">setProperty</span>(<span class="string">&#x27;--left&#x27;</span>, boxLeft);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(main);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(main);</span><br></pre></td></tr></table></figure>

<p>requestAnimationFrame在約1&#x2F;60秒後呼叫傳給它的callback函式(main)，<br>並且將timestamp當做參數傳給這個callback函式。</p>
<p>為了讓 requestAnimationFrame 能持續執行，我們在callback函式再執行一次 requestAnimationFrame。</p>
<p>如果把 timestamp console.log 出來，會發現timesatmp是以每6豪秒持續累加。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022062701.png?alt=media&token=c961a215-9334-4ef0-a5e9-dd9408fb16a3" alt="timestamp"></p>
<p><a href="https://codepen.io/tim-chou/pen/eYMOVGR">範例</a></p>
<h2 id="控制更新頻率"><a href="#控制更新頻率" class="headerlink" title="控制更新頻率"></a>控制更新頻率</h2><p>每6毫秒更新一次函式可能太快了，假設我們希望每秒更新一次畫面就好，可如下設定</p>
<h3 id="紀錄上次更新時間"><a href="#紀錄上次更新時間" class="headerlink" title="紀錄上次更新時間"></a>紀錄上次更新時間</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastRenderTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">currentTime</span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(main);</span><br><span class="line">  <span class="keyword">const</span> secondSinceLastRender = (currentTime - lastRenderTime) / <span class="number">1000</span>; <span class="comment">// 將milisecond 轉成 second</span></span><br><span class="line">  lastRenderTime = currentTime;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(currentTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以先設一個變數用來記錄上次更新畫面的時間(lastRenderTime)，然後在函式中用currentTime減掉lastRenderTime，就可以得到從上次更新到這次過了多久時間(毫秒)，可以將時間除 1000 轉換成過了幾秒。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022062702.png?alt=media&token=6ebc37f7-3bc4-4e9b-a951-4533190544ef" alt="second"></p>
<p>可以發現每次更新的間隔時間約是 6 毫秒。</p>
<h3 id="設定更新門檻"><a href="#設定更新門檻" class="headerlink" title="設定更新門檻"></a>設定更新門檻</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SPEED</span> = <span class="number">2</span>; <span class="comment">// 每秒更新次數</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">currentTime</span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(main);</span><br><span class="line">  <span class="keyword">const</span> secondSinceLastRender = (currentTime - lastRenderTime) / <span class="number">1000</span>; <span class="comment">// 將milisecond 轉成 second</span></span><br><span class="line">  <span class="keyword">if</span> (secondSinceLastRender &lt; <span class="number">1</span> / <span class="variable constant_">SPEED</span>) <span class="keyword">return</span>;</span><br><span class="line">  lastRenderTime = currentTime;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(main);</span><br></pre></td></tr></table></figure>
<p>先設定SPEED變數代表每秒更新次數，在main函式裡增加判斷</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (secondSinceLastRender &lt; <span class="number">1</span> / <span class="variable constant_">SPEED</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>用 1 除以 SPEED 可以得到每零點幾秒才能更新，上例是0.5秒更新1次，也就是每秒更新2次。<br>當 secondSinceLastRender 小於更新頻律，就將函式 return 不執行。</p>
<p>以上就完成控制更新頻律的方法了。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>(8) Git 練功坊-推送分支到遠端</title>
    <url>/2022/06/23/2022-6-23-4-git-branch-remote/</url>
    <content><![CDATA[<h2 id="推送分支上-github"><a href="#推送分支上-github" class="headerlink" title="推送分支上 github"></a>推送分支上 github</h2><p>本節會講解如何推送branch到github上。</p>
<p>首先我們先開一個新的分支，並用git checkout 分支，移動到該分支上。</p>
<p><img src="https://miro.medium.com/max/1400/1*gN684t4CgXrmbfitc8Ro2A.png" alt="add branch"></p>
<p>再來新增一個commit 記錄到該分支</p>
<p><img src="https://miro.medium.com/max/1400/1*9GKiKFBMWI50hjFgxLm7QA.png" alt="commit"></p>
<p>這時如果用git push指令想將本地端的commit推到github上，可能會出現下面錯誤。</p>
<p><img src="https://miro.medium.com/max/1400/1*050HdBhOzj3125XCFpOFzg.png" alt="error"></p>
<p>原因是因為我們可能有許多遠端數據庫，有的是測試用的、有的是正式主機用的，git不知道你的分支要推到哪個數據庫。</p>
<p>所以可用 git remote 指令來查詢本地端有多少遠端數據庫。</p>
<p><img src="https://miro.medium.com/max/1208/1*ZV4Dyk2Rq2l36mbNiGNxWA.png" alt="remote"></p>
<p>可以發現有一個 github 預設的 origin 數據庫。</p>
<p>要將分支推上github 的話 ，可使用指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push 遠端數據庫名稱 分支名稱</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1268/1*avTlKgGgw8qFA08F88x_Pg.png" alt="push"></p>
<h2 id="更改遠端數據庫名稱"><a href="#更改遠端數據庫名稱" class="headerlink" title="更改遠端數據庫名稱"></a>更改遠端數據庫名稱</h2><p>如果不想用github預設的origin數據庫名稱，可輸入: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rename 更改前名稱 更改後名稱</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/930/1*wNOekbkp-5Gsu3iiFVHGvQ.png" alt="rename"></p>
<p>在用 git remote來查詢， 會發現數據庫名稱從 origin 改成 github了。</p>
<p><img src="https://miro.medium.com/max/1400/1*6DAh5wMtkOZ-ga1uvU__fw.png" alt="git-rename"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>(3) CSS基礎篇 Grid</title>
    <url>/2022/06/28/2022-6-28-1-css-grid/</url>
    <content><![CDATA[<h2 id="Grid-排版"><a href="#Grid-排版" class="headerlink" title="Grid 排版"></a>Grid 排版</h2><p>Grid和flex一樣是用來排版的屬性，flex以單軸為主來排版，Grid則能夠同時設定兩個方向(欄和列)，能夠快速建立網頁布局。</p>
<p>Grid的屬性可以分成外部屬性和內部屬性，以下分別介紹。</p>
<h2 id="外部容器-父層"><a href="#外部容器-父層" class="headerlink" title="外部容器(父層)"></a>外部容器(父層)</h2><p>以下介紹可以在父層設定的屬性</p>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>在父層容器設定 display: grid，讓父層是 gird 容器。</p>
<ul>
<li>grid – 設定 block-level的 grid</li>
<li>inline-grid – 設定 inline-level的 grid</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid | inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grid-template-columns-grid-template-rows"><a href="#grid-template-columns-grid-template-rows" class="headerlink" title="grid-template-columns grid-template-rows"></a>grid-template-columns grid-template-rows</h3><p>設定好 display:grid後，可以用grid template 來定義版型的結構，分別設定column(欄)，和列(row)來排列格線，grid-template-columns 定義水平方向的空間，grid-template-rows 定義垂直方向的空間</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/template-column-rows-02.svg" alt="grid"><br><a href="https://css-tricks.com/wp-content/uploads/2018/11/template-column-rows-02.svg">圖片來源</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: ...  ...;</span><br><span class="line">  <span class="comment">/* e.g. </span></span><br><span class="line"><span class="comment">      1fr 1fr</span></span><br><span class="line"><span class="comment">      minmax(10px, 1fr) 3fr</span></span><br><span class="line"><span class="comment">      repeat(5, 1fr)</span></span><br><span class="line"><span class="comment">      50px auto 100px 1fr</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="attribute">grid-template-rows</span>: ... ...;</span><br><span class="line">  <span class="comment">/* e.g. </span></span><br><span class="line"><span class="comment">      min-content 1fr min-content</span></span><br><span class="line"><span class="comment">      100px 1fr max-content</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>設定單位可以使用彈性的長度、百分比<br>或用fr (等分)，如下例會將父層寬度扣掉50px後，分成三等份到三欄裡。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">1</span>fr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有重複一樣寬度的欄位，則可以用repeat設定。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat(欄位數量, 寬度)</span><br></pre></td></tr></table></figure>

<h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h3><p>grid-template-areas可以透過將每個欄位命名，將內容作分配。</p>
<p>在父層設定 grid-template-areas，可設定的值有:</p>
<ul>
<li>[欄位名稱] : 設定該欄位名稱。</li>
<li>.   設定 . 代表是空的欄位。</li>
<li>none: 代表欄位未定義。</li>
</ul>
<p>在子層則設定 grid-area 決定內容要放到哪個欄位。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-c</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-d</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: auto;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">&quot;header header header header&quot;</span></span><br><span class="line">    <span class="string">&quot;main main . sidebar&quot;</span></span><br><span class="line">    <span class="string">&quot;footer footer footer footer&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/dddgrid-template-areas.svg" alt="grid-area"><br><a href="https://css-tricks.com/wp-content/uploads/2018/11/dddgrid-template-areas.svg">圖片來源</a></p>
<h3 id="grid-gap-grid-column-gap-grid-row-gap"><a href="#grid-gap-grid-column-gap-grid-row-gap" class="headerlink" title="grid-gap, grid-column-gap, grid-row-gap"></a>grid-gap, grid-column-gap, grid-row-gap</h3><p>設定水平與垂直的欄位間隔</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">column-gap</span>: &#123; <span class="attribute">column-gap</span> &#125;;  //設定每欄的間隔</span><br><span class="line"><span class="attribute">row-gap</span>: &#123; <span class="attribute">row-gap</span> &#125;; //設定每列的間隔</span><br><span class="line"><span class="attribute">gap</span>: &#123; <span class="attribute">row-gap</span> &#125; &#123; <span class="attribute">column-gap</span> &#125;;  // 同時設定欄和列的間隔</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> auto <span class="number">80px</span>; </span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">row-gap</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h3><p>justify-items 可以設定子元素水平對齊格子的方式，可設定的值有:</p>
<ul>
<li>start: 對齊開頭</li>
<li>end: 對齊末端</li>
<li>center: 對齊中間</li>
<li>stretch: 填滿格子(預設值)</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/justify-items-start.svg" alt="justify-items: start"></p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>align-items 可以設定子元素垂直對齊格子的方式，可設定的值有:</p>
<ul>
<li>start: 對齊頂端</li>
<li>end: 對齊底部</li>
<li>center: 對齊中間</li>
<li>stretch: 填滿格子(預設值)</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/align-items-center.svg" alt="align-items: center"></p>
<h3 id="place-items"><a href="#place-items" class="headerlink" title="place-items"></a>place-items</h3><p>place-items 能同時設定 justify-items跟align-items</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; / &lt;justify-items&gt;</span><br></pre></td></tr></table></figure>
<p>第一個值設定 align-items，第二個值設定 justify-items。如果只設一個值，則會同時套用到 justify-items跟align-items。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  place-items: center;  // 快速將內容置中於格子內</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="justify-content、align-content"><a href="#justify-content、align-content" class="headerlink" title="justify-content、align-content"></a>justify-content、align-content</h3><p>有時候你的格子尺寸可能會小於父層grid容器，此時可以用 justify-content 同時調整所有子元素的水平對齊，align-content 同時調整所有子元素的垂直對齊</p>
<p>可設定的值:</p>
<ul>
<li>start: 對齊開頭</li>
<li>end: 對齊末端</li>
<li>center: 對齊中間</li>
<li>stretch: 填滿格子(預設值)</li>
<li>space-around: 平均分配寬度和間距</li>
<li>space-between: 平均分配寬度，第一項和最後一項貼齊邊緣</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: end;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/justify-content-end.svg" alt="justify-content: end"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: space-around;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/align-content-space-around.svg" alt="align-content: space-around"></p>
<h3 id="grid-auto-columns-、-grid-auto-rows"><a href="#grid-auto-columns-、-grid-auto-rows" class="headerlink" title="grid-auto-columns 、 grid-auto-rows"></a>grid-auto-columns 、 grid-auto-rows</h3><p>當我們的grid-items數量超過我們設定的格線，或是將元素指定到格線以外時，會自動產生格線。<br>如下我們設定一個 2 x 2的格線。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">60px</span> <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">90px</span> <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但子元素設定的區域超過格線內，會自動產生格線。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">5</span> / <span class="number">6</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/grid-auto-columns-rows-02.svg" alt="gird"></p>
<p>此時可以設定 grid-auto-columns | grid-auto-rows 來指定自動產生的格線寬度。等於是設定格線寬度或高度的預設值，當格線沒有被 grid-template-columns 設定寬度時，就套用 grid-auto-columns的值。 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-auto-columns</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><p>當有grid-item沒有被指定位置時，gird會自動排列這些grid-item，排列方式如下:</p>
<ul>
<li>row: 水平排列 (預設值)</li>
<li>column: 垂直排列</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span> <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">30px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">grid-auto-flow</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-e</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">5</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/grid-auto-flow-01.svg" alt="水平排列"></p>
<p>item-b、item-c、item-d 因為沒有指定位置，自動依照grid-auto-flow水平排列</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/grid-auto-flow-02.svg" alt="垂直排列"></p>
<p>item-b、item-c、item-d 因為沒有指定位置，自動依照grid-auto-flow垂直排列</p>
<h2 id="內部元素-子層"><a href="#內部元素-子層" class="headerlink" title="內部元素(子層)"></a>內部元素(子層)</h2><p>以下介紹可以在內部元素設定的屬性</p>
<h3 id="grid-column-start-grid-column-end-grid-row-start-grid-row-end"><a href="#grid-column-start-grid-column-end-grid-row-start-grid-row-end" class="headerlink" title="grid-column-start, grid-column-end, grid-row-start, grid-row-end"></a>grid-column-start, grid-column-end, grid-row-start, grid-row-end</h3><p>物件所佔的空間位置，Column 及 Row 所到的起始點及終點</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>number : 用數字表示 物件 所在的線。</li>
<li>span number - 物件會橫跨的欄位數</li>
<li>span name - 物件所在的 grid 名稱</li>
<li>auto - 自動</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">3</span>; <span class="comment">/* 物件起始線 */</span></span><br><span class="line">  <span class="attribute">grid-column-end</span>: span <span class="number">4</span>; <span class="comment">/* 終點線 = 物件所佔的空間數 */</span>  </span><br><span class="line">  <span class="attribute">grid-row-end</span>: auto; // 不設定終點線</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grid-column-、-grid-row"><a href="#grid-column-、-grid-row" class="headerlink" title="grid-column 、 grid-row"></a>grid-column 、 grid-row</h3><p>上面屬性的縮寫，使用斜線 (&#x2F;) 隔開屬性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br><span class="line">  <span class="attribute">grid-row</span>: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>start-line: 開始的格線</li>
<li>end-line : 結束的格線</li>
<li>span value: 指定橫跨的欄位數</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-c</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span> / span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: third-line / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/grid-column-row.svg" alt="grid-column"></p>
<h3 id="justify-self"><a href="#justify-self" class="headerlink" title="justify-self"></a>justify-self</h3><p>指定單一格子內的grid-item水平對齊的方式，可設定的值如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  justify-self: start | end | center | <span class="built_in">stretch</span>(預設值);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>範例: </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/justify-self-start.svg" alt="justify-self"></p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>指定單一格子內的grid-item垂直對齊的方式，可設定的值如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>範例: </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/align-self-end.svg" alt="align-self"></p>
<h3 id="place-self"><a href="#place-self" class="headerlink" title="place-self"></a>place-self</h3><p>是 align-self跟justify-self的縮寫，用法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">place-self : &lt;align-self&gt; / &lt;justify-self&gt; </span><br></pre></td></tr></table></figure>

<p>第一個值設定 align-self，第二個值設定justify-self。如果只設定一個值，則會同時套用到align-self跟justify-self。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  place-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/place-self-center.svg" alt="center"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  place-self: center stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/11/place-self-center-stretch.svg" alt="place-self"></p>
<h2 id="特殊單位與函式"><a href="#特殊單位與函式" class="headerlink" title="特殊單位與函式"></a>特殊單位與函式</h2><h3 id="fr-單位"><a href="#fr-單位" class="headerlink" title="fr 單位"></a>fr 單位</h3><p>在grid裡，可以用 fr 作為單位，1fr指的是 1等分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: 1fr 3fr;</span><br></pre></td></tr></table></figure>

<p>上面我們設定的兩欄就分別代表 25% 和 75% 的寬度。</p>
<p>fr 也可以搭配其他單位使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: 50px min-content 1fr;</span><br></pre></td></tr></table></figure>

<h3 id="關鍵字"><a href="#關鍵字" class="headerlink" title="關鍵字"></a>關鍵字</h3><p>當我們在設定欄位長寬時，可以用 px 、% 、rem 等等，也可以使用關鍵字設定。</p>
<ul>
<li>min-content: 指的是內容的最小尺寸</li>
<li>max-content: 指的是內容的最大尺寸</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022062901.png?alt=media&token=acf4677c-2652-40d6-aa52-6fd328611d56" alt="min-content"></p>
<p>假設有一個grid-item是一段句子:</p>
<ul>
<li>min-content: 句子裡最長的字的寬度。</li>
<li>max-content: 完整句子的寬度。</li>
</ul>
<h3 id="特殊函式"><a href="#特殊函式" class="headerlink" title="特殊函式"></a>特殊函式</h3><ul>
<li>minmax(最小寬度, 最大寬度)</li>
</ul>
<p>使用 minmax 可以同時設定欄位的最小和最大寬度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: minmax(100px, 1fr) 3fr; </span><br></pre></td></tr></table></figure>

<ul>
<li>repeat(欄位數量, 欄位寬度)</li>
</ul>
<p>當要設定的欄位寬度都一樣時，可以用 repeat方法來設定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns:</span><br><span class="line">  1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;</span><br><span class="line"></span><br><span class="line">/* easier: */</span><br><span class="line">grid-template-columns:</span><br><span class="line">  repeat(8, 1fr);</span><br><span class="line"></span><br><span class="line">/* especially when: */</span><br><span class="line">grid-template-columns:</span><br><span class="line">  repeat(8, minmax(10px, 1fr));</span><br></pre></td></tr></table></figure>

<p>在使用 repeat() 時，如果不確定自己要的重複次數，可以使用 auto-fill 和 autofit 讓重複的網格持續填滿。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  gird-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">50px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例，因為容器寬度是500px, 設定auto-fill 會產生 5 * 3的網格。</p>
<p>至於 auto-fill 和 auto-fit的差異在:</p>
<ul>
<li>auto-fill: 盡量產生重複的欄位。</li>
<li>auto-fit: 盡量產生重複的欄位，但多的格子會被設為0px，折疊起來。</li>
</ul>
<p><a href="https://jhlstudy.blogspot.com/2018/07/grid-layout-auto-fill-auto-fit_8.html">詳細解說文章看這</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS基礎篇</tag>
      </tags>
  </entry>
  <entry>
    <title>(9) Git 練功坊-取消修改</title>
    <url>/2022/06/30/2022-6-30-1-git-reset/</url>
    <content><![CDATA[<h2 id="取消修改"><a href="#取消修改" class="headerlink" title="取消修改"></a>取消修改</h2><p>在 git 裡主要用兩種方法來取消修改，一種是 git reset，另外一種是 git revert。</p>
<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>git reset 利用把分支的參考點退回到上一個 commit 來取消修改。你可以認為這是在”重寫歷史”。git reset 往回移動 branch，原來的 branch 所指向的 commit 好像從來沒有存在過一樣。</p>
<p><img src="https://miro.medium.com/max/504/1*YExCjHyozE-SQLif6Egfhg.png" alt="reset"><br><img src="https://miro.medium.com/max/674/1*zFOz7tr23cEQG2OTkffCjg.png" alt="reset"></p>
<p>git reset 可以分為 –hard、 –soft 、 –mixed 三種模式</p>
<h3 id="reset-–mixed"><a href="#reset-–mixed" class="headerlink" title="reset –mixed"></a>reset –mixed</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --mixed HEAD~1   # 數字表示移動到 HEAD後面第幾個</span><br></pre></td></tr></table></figure>

<p>–mixed 是預設的參數，如果沒有特別加參數，git reset 指令將會使用 –mixed 模式。這個模式會把暫存區的檔案丟掉，但不會動到工作目錄的檔案，也就是說 Commit 拆出來的檔案會留在工作目錄，但不會留在暫存區。</p>
<h3 id="reset-–soft"><a href="#reset-–soft" class="headerlink" title="reset –soft"></a>reset –soft</h3><p>這個模式下的 reset，工作目錄跟暫存區的檔案都不會被丟掉，所以看起來就只有 HEAD 的移動而已。也因此，Commit 拆出來的檔案會直接放在暫存區。</p>
<h3 id="reset-–hard"><a href="#reset-–hard" class="headerlink" title="reset –hard"></a>reset –hard</h3><p>hard模式下，不管是工作目錄以及暫存區的檔案都會丟掉。</p>
<h3 id="取消reset"><a href="#取消reset" class="headerlink" title="取消reset"></a>取消reset</h3><p>如果你reset完後悔，輸入 git checkout + reset點的hash值，是可以回復的。</p>
<p><img src="https://miro.medium.com/max/290/1*iP8bv0VETpcpfPbl5xEnFA.png" alt="hash"><br><img src="https://miro.medium.com/max/636/1*YzByXkMhsnyLdSpM6dQGjQ.png" alt="checkout"></p>
<p>但如果有遠端備份(github)的話，不建議用git reset ，因為如果你將本機reset過的紀錄再push一次到遠端，你的同事又從本地端push一次到遠端，那你想reset不要的紀錄又回到遠端了。</p>
<h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>為了將你想取消的紀錄分享給你的同事，可以用git revert，概念是再做一個新的 Commit，來取消你不要的 Commit，新的commit點上會有 ‘ 代表是revert 的點。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git revert + 要刪除的commit點</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/574/1*c_R6Jsz3I7bhynusCX2Hyg.png" alt="新增C2&#39; 來取消C2"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>(1) Hexo 部落格安裝</title>
    <url>/2022/06/07/2022-6-7-Hexo-%E9%83%A8%E8%90%BD%E6%A0%BC%E5%AE%89%E8%A3%9D%E8%88%87%E9%83%A8%E5%B1%AC/</url>
    <content><![CDATA[<h2 id="什麼是-Hexo？"><a href="#什麼是-Hexo？" class="headerlink" title="什麼是 Hexo？"></a>什麼是 Hexo？</h2><p>Hexo 是一個快速、簡單且強大的網誌框架。Hexo 使用 Markdown（或其他標記語言）解析您的文章，並在幾秒鐘內，透過漂亮的主題產生靜態檔案。</p>
<h2 id="安裝需求"><a href="#安裝需求" class="headerlink" title="安裝需求"></a>安裝需求</h2><ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低於8.10，建議使用 Node.js 10.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<p>若您的電腦已經安裝上述的必備軟體，那麼恭喜您！只需要透過 npm 即可完成 Hexo 的安裝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>一旦 Hexo 完成後，請執行下列指令，Hexo 會在指定資料夾中建立所有您需要的檔案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>建立完成後，專案資料夾會有下列檔案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<h2 id="資料夾配置說明"><a href="#資料夾配置說明" class="headerlink" title="資料夾配置說明"></a>資料夾配置說明</h2><p>以下說明不同資料夾功能</p>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>scaffolds 資料夾裡放的是md範例檔案，當我們要寫新聞章時，可以將範例檔另存到source資料夾裡，來開始撰寫。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060702.png?alt=media&token=3ee586a3-0af2-4191-8cac-1d299028f03b" alt="scaffolds圖片範例"></p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>source 資料夾是放置文章的地方。所有的檔案或是資料夾通常都會在這邊，開頭會加上 _(底線) 來命名，讓這些資料夾或是檔案也成為隱藏檔案而被忽略，除了 _posts 資料夾以外。Markdown 和 HTML 檔案會被發布並存放到 public 資料夾，而其他檔案沒有以底線命名的就會被拷貝過去。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060701.png?alt=media&token=a71a827f-ea1c-4ad8-b570-0ce5372488b6" alt="source資料夾"></p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>themes 資料夾放的是hexo的主題樣式，後續更換主題也是將檔案載到這個地方。</p>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>_config.yml 是網站的配置檔案（如下圖），網站的各種配置設定都在這邊，例如：網頁標題、網站描述、網站的網址、路徑等等，詳細內容可以參考： <a href="https://hexo.io/zh-tw/docs/configuration">https://hexo.io/zh-tw/docs/configuration</a></p>
<p>大家可以自行修改看看，如下圖</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060801.png?alt=media&token=a28a52df-edb2-4848-a690-9fe3f5807343" alt="config修改"></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>(5) Hexo-新增頁面</title>
    <url>/2022/06/09/2022-6-9-1-Hexo-%E6%96%B0%E5%A2%9E%E9%A0%81%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="新增頁面"><a href="#新增頁面" class="headerlink" title="新增頁面"></a>新增頁面</h2><p>與新增文章不同，我們也可以在hexo 裡新增一些頁面，用來放作者介紹等資訊。</p>
<p>建立頁面的指令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;頁面名稱（網址用）&quot;</span><br></pre></td></tr></table></figure>

<p>新增好的頁面會在放在source資料夾底下</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/202206009.png?alt=media&token=4e8aaa96-e6ea-4a18-9bb1-37d18acec1b7" alt="about-page"></p>
<p>頁面預設只有 title 以及 date， 而頁面預設是可以留言的，如果不開放留言則可以新增 comments 設定為false。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/20220600902.png?alt=media&token=6fbb9f83-991a-4e9b-b2dc-9291231e6dfb" alt="comment"></p>
<h2 id="新增分類與標籤頁"><a href="#新增分類與標籤頁" class="headerlink" title="新增分類與標籤頁"></a>新增分類與標籤頁</h2><p>我們也可在hexo裡增加分類頁面與標籤頁面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags  // 建立標籤頁</span><br><span class="line">hexo new page categories // 建立分類頁</span><br></pre></td></tr></table></figure>

<p>頁面一樣會新增在source資料夾底下，進入 <code>source/tags</code>，會看到<code>index.md</code>檔，<br>將裡面內容再加入以下這行即可 <code>type: &quot;tags&quot;</code>。</p>
<p>最後找到主題 (theme) 設置文件 (_config.yml)，這邊以 NexT 為例，將 tags 及 categories 前的#字號移除即可。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/20220600903.png?alt=media&token=f53ac521-d777-4cc9-b6e0-c34b04da5458" alt="theme"></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>(4) CSS基礎篇 Flex</title>
    <url>/2022/06/29/2022-6-29-1-css-flex/</url>
    <content><![CDATA[<h2 id="什麼是-flex"><a href="#什麼是-flex" class="headerlink" title="什麼是 flex"></a>什麼是 flex</h2><p>flex 和grid一樣是排版用的 css屬性，使用flex時可分為外容器屬性與內元件屬性。以下分別介紹各屬性使用方法。</p>
<h2 id="外容器屬性"><a href="#外容器屬性" class="headerlink" title="外容器屬性"></a>外容器屬性</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>啟用flex的第一步，就是在外容器設定 display: flex;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在父層設定 display:flex 可以讓子層區塊並排<br><img src="https://miro.medium.com/max/972/1*cPIZHT7a0P0v5mljoBjdvg.png" alt="flex"></p>
<p>當子層寬度超過父層時，flex也會依照比例自動做調整，不會跑版，並且當子層其中一個元素高度變高，其他元素也會自動等高。</p>
<p><img src="https://miro.medium.com/max/1246/1*yO5cUEPDPz7of4-KZyoTCw.png" alt="自動等高"></p>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>flex的主軸指的是資料的流向 ，預設是從左到右排版，可以設定的值如下:</p>
<ul>
<li><p>flex-direction: row; 從左到右</p>
</li>
<li><p>flex-direction: row-reverse; 從右到左</p>
</li>
<li><p>flex-direction: column; 從上到下</p>
</li>
<li><p>flex-direction: column-reverse; 從下到上</p>
</li>
</ul>
<p><img src="https://miro.medium.com/max/1400/1*jgot2tuYYebDZFe6ZTssyQ.png" alt="主軸"></p>
<h3 id="justfy-content"><a href="#justfy-content" class="headerlink" title="justfy-content"></a>justfy-content</h3><p>依照主軸的方向(flex-direction)，可以設定 justfy-content 來對齊子元素。所以實際對齊方向是水平或垂直，要依主軸的方向而定喔。</p>
<p><img src="https://miro.medium.com/max/1400/1*UDLawhonhqaaTSbx5lwa9Q.png" alt="justify-content"></p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>超出範圍時是否換行的屬性，分為換行、不換行、換行時反轉。</p>
<p>預設是 flex-wrap:nowrap 不換行，設定flex-wrap:wrap則會換行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><img src="https://miro.medium.com/max/1400/1*gUKuGGbB3B0AfezDlzulZw.png" alt="交錯軸"></p>
<p>和主軸垂直的方向稱為交錯軸，例如主軸是水平的，那交錯軸就是垂直。align-items屬性可以設定交錯軸的對齊方式。</p>
<p><img src="https://miro.medium.com/max/1400/1*jxzyFebBjrX8jyZ6VFF9bQ.png" alt="align-items"></p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>多行物件的交錯軸對齊，可以使用的屬性和align-items一樣。</p>
<p><img src="https://miro.medium.com/max/1348/1*bvaLIRwiLKGak1nOLhCwXg.png" alt="align-content"></p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>flex-flow 是 flex-direction 與 flex-wrap 的縮寫，所以只要在這前後帶上相對應的值即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;<span class="string">&#x27;flex-direction&#x27;</span>&gt; || &lt;<span class="string">&#x27;flex-wrap&#x27;</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="內元件屬性"><a href="#內元件屬性" class="headerlink" title="內元件屬性"></a>內元件屬性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>用來指定子層物件的順序，order 預設都是 0。小於 0 的元件會往前排，大於 0 往後排。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">order</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/818/1*s71cQM9RnsxFauhOIt6q6w.png" alt="order"></p>
<h3 id="flex-grow-伸展"><a href="#flex-grow-伸展" class="headerlink" title="flex-grow 伸展"></a>flex-grow 伸展</h3><p>flex-grow 設定元件的伸展性，會把剩下的空間份配給子物件，並針對子物件去設定伸展的比例，預設值為 0不會縮放。<br>如下圖: 設定flex-grow: 2 的元素會有較大的位置。<br><img src="https://miro.medium.com/max/548/1*3qDfiEcjgxQvyup9ygcAww.png" alt="flex-grow"></p>
<h3 id="flex-shrink-收縮"><a href="#flex-shrink-收縮" class="headerlink" title="flex-shrink 收縮"></a>flex-shrink 收縮</h3><p>flex-shrink: 元件的收縮性，是一個數值，當空間分配還不足時的當前元件的收縮性，預設值為 1 會收縮，如果設置為 0 則不會縮放。</p>
<p><img src="https://miro.medium.com/max/1400/1*1kyY6pGhIUCz79CHJ74deQ.png" alt="flex-shrink"></p>
<p>上圖當子層物件寬度超過父層時，如果將子層設定 flex-shrink: 0 ，代表不收縮，此時子層會超出父層寬度。</p>
<p><img src="https://miro.medium.com/max/1400/1*nANSTLkevML4QdU2VKIHmQ.png" alt="flex-shrink"></p>
<p>當設定其中一個子層 flex-shrink: 0 ，其他為1時，設定0的物件不收縮，保持原來寬度，設定shrink的則依比例收縮。</p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>flex-basis 可以設定子元件 flex-item 的主軸長度。</p>
<ul>
<li><p>當主軸為橫向時，對應到元件的寬，</p>
</li>
<li><p>當主軸是直向時，對應到元件的高。</p>
</li>
</ul>
<p>可以設定每個flex-item 的 flex-basis 為 0， 就可以依照想要的比例來設定flex-grow。</p>
<p><img src="https://miro.medium.com/max/1400/1*GN7XSfKQGUABUGAY-nIjSg.png" alt="flex-basis"></p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>align-self 可以調整單一物件的交錯軸對齊，可以使用的屬性和align-items一樣。</p>
<p><img src="https://css-tricks.com/wp-content/uploads/2018/10/align-self.svg" alt="align-self"></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS基礎篇</tag>
      </tags>
  </entry>
  <entry>
    <title>(3) Hexo-基礎Hexo指令</title>
    <url>/2022/06/08/2022-6-8-Hexo-%E5%9F%BA%E7%A4%8EHexo%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文將會介紹一些基礎的Hexo指令，那就一起看下去吧。</p>
<h2 id="基礎Hexo指令"><a href="#基礎Hexo指令" class="headerlink" title="基礎Hexo指令"></a>基礎Hexo指令</h2><ul>
<li><code>hexo new &#39;新文章&#39;</code>  新增文章</li>
<li><code>hexo generate</code> 產生編譯後的靜態檔案</li>
<li><code>hexo server</code> 開啟一個本地端伺服器</li>
<li><code>hexo clean</code> 清除暫存檔案</li>
<li><code>hexo deploy</code> 部屬靜態檔案</li>
</ul>
<h2 id="產生新文章"><a href="#產生新文章" class="headerlink" title="產生新文章"></a>產生新文章</h2><p>要產生一篇新的文章，可以用 <code>hexo new &#39;新文章</code> 指令，產生後的文章會放在 <code>source</code> 資料夾的 <code>_posts</code>裡</p>
<h2 id="產生編譯後的檔案"><a href="#產生編譯後的檔案" class="headerlink" title="產生編譯後的檔案"></a>產生編譯後的檔案</h2><p>當文章寫完後，需要將md檔案進行編譯，此時可以用 <code>hexo generate</code> 指令，編譯完後會產生一個 <code>public</code> 資料夾，作為之後部屬使用。<br>此指令的簡寫為 <code>hexo g</code></p>
<h2 id="開啟一個本地端伺服器"><a href="#開啟一個本地端伺服器" class="headerlink" title="開啟一個本地端伺服器"></a>開啟一個本地端伺服器</h2><p>當靜態檔案編譯完後，可以用 <code>hexo server</code> 指令開啟一個本地端的模擬伺服器，用來即時瀏覽我的寫完的文章，此指令的簡寫為 <code>hexo s</code></p>
<h2 id="清除暫存檔案"><a href="#清除暫存檔案" class="headerlink" title="清除暫存檔案"></a>清除暫存檔案</h2><p><code>hexo clean</code> 指令主要用來清除一些奇怪的暫存檔案，通常部屬前會先清理一遍。</p>
<h2 id="部屬靜態檔案"><a href="#部屬靜態檔案" class="headerlink" title="部屬靜態檔案"></a>部屬靜態檔案</h2><p><code>hexo deploy</code> 將我們的靜態網站部屬到雲端使用的指令，詳細用流程在之後部屬的章節會提到。<br>此指令的簡寫為 <code>hexo d</code></p>
<p>這就是今天 hexo 指令的介紹囉。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>(2) Hexo 撰寫第一篇文章</title>
    <url>/2022/06/08/2022-6-8-Hexo-%E6%92%B0%E5%AF%AB%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="建立你的第一篇文章"><a href="#建立你的第一篇文章" class="headerlink" title="建立你的第一篇文章"></a>建立你的第一篇文章</h2><p>我們可以在Vscode 中，開啟上個章節所建立的專案</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060802.png?alt=media&token=cba3f60e-8fba-4f61-83b4-9668e01bd2e7" alt="專案圖片"></p>
<p>在Vscode中用快捷鍵 Control + ESC，開啟終端機 </p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060803.png?alt=media&token=e185edcc-77fc-4d1e-8499-b6c467085d8b" alt="終端機"></p>
<p>然後下方終端機輸入 <code>hexo new &#39;我的第一篇部落格文章&#39;</code> 輸入完後會顯示 <code>INFO  Generated: 2022/06/07/2022-6-7-Hexo-部落格安裝與部屬/index.html</code> 代表文章被順利建立在source資料夾裡的 <code>_posts</code>底下。</p>
<h2 id="MD-內容"><a href="#MD-內容" class="headerlink" title="MD 內容"></a>MD 內容</h2><p>在md檔案裡，最上面會有可以填寫 標題等欄位<br><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060804.png?alt=media&token=27df0ccb-a65b-434b-aece-6c7af864d641" alt="標題"></p>
<p>文章撰寫則以Markdown格式為主，若不了解Markdown格式，可以參考 <a href="https://markdown.tw/">markdown</a></p>
<p>以上就是撰寫文章的方法囉</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>(6) Hexo-新增佈景主題</title>
    <url>/2022/06/09/2022-6-9-2-Hexo-%E6%96%B0%E5%A2%9E%E4%BD%88%E6%99%AF%E4%B8%BB%E9%A1%8C/</url>
    <content><![CDATA[<h2 id="挑選佈景主題"><a href="#挑選佈景主題" class="headerlink" title="挑選佈景主題"></a>挑選佈景主題</h2><p>除了Hexo預設的版型外，也可以新增不同的佈景主題上去。<br>可以先來到 <a href="https://hexo.io/themes/">Hexo 官網</a>的主題區挑選你喜歡的主題</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060904.png?alt=media&token=9deec5ff-8e70-433d-810c-412773e6566d" alt="theme-page"></p>
<p>本文以 <a href="https://theme-next.js.org/">NexT</a> 主題為例，點選後來到NextT官網。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060905.png?alt=media&token=ae056e59-0cfc-4958-8d21-e18bfa158b6d" alt="NEXTT"></p>
<p>點選左上角doc可以進入教學文件。</p>
<h2 id="下載NextT主題"><a href="#下載NextT主題" class="headerlink" title="下載NextT主題"></a>下載NextT主題</h2><p>這邊使用NPM來下載主題，在你的Vscode的終端機輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<h2 id="主題設定檔"><a href="#主題設定檔" class="headerlink" title="主題設定檔"></a>主題設定檔</h2><p>下載好後會發現我們現在有兩個 <code>_config.yml</code>設定檔</p>
<ol>
<li>第一個在我們專案的根目錄，也就是一開始hexo的設定檔</li>
<li>第二個在我們主題的目錄下，(e.g. <code>thems/next/_config.yml</code> or <code>node_modules/hexo-theme-next/_config.yml</code>)</li>
</ol>
<p>以下稱第一個為hexo設定檔，第二個為NextT設定檔。</p>
<h2 id="hexo設定檔"><a href="#hexo設定檔" class="headerlink" title="hexo設定檔"></a>hexo設定檔</h2><p>當我們下載完NextT主題後，到hexo設定檔裡，找到theme選項，並將值改為 next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h2 id="NextT設定檔"><a href="#NextT設定檔" class="headerlink" title="NextT設定檔"></a>NextT設定檔</h2><p>官網不建議我們直接修改NextT設定檔，所以我們可以在專案根目錄新增一個 <code>/_config.next.yml</code>檔案。<br>我們可以複製所有NextT設定檔裡的資料到我們新增的 _config.next.yml 檔案裡。</p>
<p>NextT有提供四種不同風格的版型，可以在此挑選你喜愛的版型，只要將 # 取消或勾選即可</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060906.png?alt=media&token=cacc04e2-a6d7-4992-b096-37bb1a2bb206" alt="scheme"></p>
<p>Next 也提供dark mode可以選擇，只要將dark mode改為true即可</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060907.png?alt=media&token=c97c2e01-2382-4dec-abee-f64b3e5cb980" alt="darkmode"></p>
<p>以上都設定好後，就可發現我們的部落格套用了nextT主題囉</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060908.png?alt=media&token=7b16821f-7ef1-4b28-b075-5be943ebfd76" alt="theme"></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>(4) Hexo-部屬部落格</title>
    <url>/2022/06/08/2022-6-8-Hexo-%E9%83%A8%E5%B1%AC%E9%83%A8%E8%90%BD%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="Gihub-Pages"><a href="#Gihub-Pages" class="headerlink" title="Gihub Pages"></a>Gihub Pages</h2><p>本文會使用 Github Pages ，來部屬我們的部落格。</p>
<h2 id="創建repository"><a href="#創建repository" class="headerlink" title="創建repository"></a>創建repository</h2><p>首先來到Gihub創建一個新的 repository， 這個repository會用來放我們的部落格</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060805.png?alt=media&token=78b7c432-452d-4595-9c87-e8492d3a445d" alt="repository"></p>
<p>點選 create new repository來創建我們的儲存庫，這邊要先說明每個Github帳號都有一個主儲存庫，網址會呈現如下圖 new 的網址，由你的 <code>github名稱 + github.io</code> 組成。<br>每個Github帳號的主儲存庫只有一個，通常會用來放最重要的內容，這邊就用來放我們的部落格</p>
<p>在創建時儲存庫時，可以將主儲存庫的網址填入</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060806.png?alt=media&token=329c82e8-b023-429d-a0f4-0e1efddbda06" alt="repository-name"></p>
<p>建立好後來到這個畫面</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022060807.png?alt=media&token=a7adcd93-9818-4df2-8a1d-c6285c2b5c1a" alt="建立儲存庫"></p>
<p>此時回到Vscode，開啟一個新的專案，並輸入以下指令，將git專案建立好後推到github上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/tim8076/test.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>專案推上 github 後，開啟專案底下的 <code>_config.yml</code> 檔案，找到deploy項目，並將內容修改如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/tim8076/tim8076.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>這邊type選用git，repo則貼上你的儲存庫的網址，branch選擇 main</p>
<h2 id="部屬部落格"><a href="#部屬部落格" class="headerlink" title="部屬部落格"></a>部屬部落格</h2><p>當完成以上步驟後，要先安裝 hexo 自動部屬的套件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>安裝完後，先使用<code>hexo clean</code> 清除暫存檔，再用 <code>hexo g</code> 來編譯靜態檔，最後用 <code>hexo d</code>來將網站部署上github</p>
<p>部屬完後輸入你的 githubpages網址，如 <a href="https://tim8076.github.io/">https://tim8076.github.io/</a>，就可以看到部屬好的部落格了。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax解說系列(1) Ajax的原理</title>
    <url>/2022/07/01/2022-7-1-1-js-ajax/</url>
    <content><![CDATA[<h2 id="Ajax-原理"><a href="#Ajax-原理" class="headerlink" title="Ajax 原理"></a>Ajax 原理</h2><p>AJAX即「Asynchronous JavaScript and XML」（非同步的JavaScript與XML技術）</p>
<p>傳統的Web應用允許使用者端填寫表單（form），當送出表單時就向網頁伺服器傳送一個請求。伺服器接收並處理傳來的表單，然後送回一個新的網頁，但這個做法浪費了許多頻寬，因為在前後兩個頁面中的大部分HTML碼往往是相同的。</p>
<p>Ajax 透過瀏覽器發送一個網頁請求給伺服器，伺服器再回傳對應資料，如此不用重新整理網頁，就能更新資料，並避免了在網路上傳送那些沒有改變的資訊。網頁請求代碼可分為以下幾種</p>
<h2 id="網頁請求狀態碼"><a href="#網頁請求狀態碼" class="headerlink" title="網頁請求狀態碼"></a>網頁請求狀態碼</h2><ul>
<li>資訊回應 (Informational responses, 100–199),</li>
<li>成功回應 (Successful responses, 200–299),</li>
<li>重定向 (Redirects, 300–399),</li>
<li>用戶端錯誤 (Client errors, 400–499),</li>
<li>伺服器端錯誤 (Server errors, 500–599).</li>
</ul>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax解說系列(3) Fetch</title>
    <url>/2022/07/01/2022-7-1-3-js-fetch/</url>
    <content><![CDATA[<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>和 XMLHttpRequest一樣，Fetch 是window物件底下的方法，用來發送網路請求。當請求成功，fetch就會回傳一個promise物件(狀態是fulfilled)，這物件內會帶有response物件，裏面會放有我們想抓的資料。</p>
<p>以下介紹不同請求類型的用法:</p>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p><img src="https://miro.medium.com/max/919/1*aa1YL0BX_PnipFIh2nJgJQ.png" alt="get"></p>
<p>單純發送get請求時，在fetch填入api的url，在第一次.then接收時，要用.json()方法，將資料轉為物件，此時會返回一個promise。<br>在用一個then去接收promise返回的資料，此時就是真正的物件資料。</p>
<h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><p><img src="https://miro.medium.com/max/1155/1*FArkQAKzv0-HP0tZ7_PRmQ.png" alt="post"></p>
<ol>
<li>使用post資料到伺服器時，要設定 method: ‘POST’，</li>
<li>headers 要設定 傳送資料的格式:</li>
</ol>
<ul>
<li>json 格式 : application&#x2F;json</li>
<li>傳統表單格式: application&#x2F;x-www-form-urlencoded</li>
</ul>
<ol start="3">
<li>body 內放要傳送的資料，記得資料要用JSON.stringify轉為字串傳入。</li>
<li>最後用 .then .catch接收回傳資料。</li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax解說系列(2) XMLHttpRequest</title>
    <url>/2022/07/01/2022-7-1-2-js-XMLHttpRequest/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>XMLHttpRequest (XHR) 是 JavaScript 著名的 古老 API，能透過它操作 HTTP 請求，進行網路作業，<br>擷取資料的同時，卻不需進行頁面重載 (page reload)，以下介紹使用方法</p>
<h2 id="建立物件"><a href="#建立物件" class="headerlink" title="建立物件"></a>建立物件</h2><p>我們可以透過new 一個 XMLHttpRequest 物件 ，來向伺服器發送請求，這個XMLHttpRequest 物件包含許多屬性可使用。</p>
<p><img src="https://miro.medium.com/max/714/1*e4T8bl0a1-yLF-6ty31wSA.png" alt="xml"><br><img src="https://miro.medium.com/max/1155/1*32TavTHF8TJWAcE5XIOyGw.png"></p>
<p>其中 readyState 的狀態分為幾種，分別代表發出請求的不同階段</p>
<ul>
<li>1 代表你用了 open 但還沒有把資料傳過去</li>
<li>2 偵測到你用 send</li>
<li>3 資料loading 中 ，可能資料太大</li>
<li>4 你撈到資料了，數據完全接收了</li>
</ul>
<h2 id="設定請求"><a href="#設定請求" class="headerlink" title="設定請求"></a>設定請求</h2><p>使用 open() 方法，設定請求，<br>請求方法 除了 GET 與 POST，還能使用 PUT、DELETE、HEAD、OPTIONS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;請求方法&#x27;</span>, <span class="string">&#x27;請求資源網址&#x27;</span>, <span class="literal">true</span> | <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>其中第三個參數代表: </p>
<p>true 代表非同步，不等資料回傳，程式碼就會繼續跑。<br>false 代表同步，資料回傳，程式碼才繼續跑。</p>
<h2 id="發送請求"><a href="#發送請求" class="headerlink" title="發送請求"></a>發送請求</h2><p>使用 send() 方法，發送請求。</p>
<p><img src="https://miro.medium.com/max/1155/1*DvrAzDHjq31_kdppxvivyQ.png" alt="send"></p>
<h2 id="監聽事件"><a href="#監聽事件" class="headerlink" title="監聽事件"></a>監聽事件</h2><p>當使用非同步時，要監聽onload事件，確認資料撈回後，再進行處理。</p>
<p><img src="https://miro.medium.com/max/1155/1*-UC5WKjY-A5ClIMLUM3PbQ.png" alt="on-load"></p>
<h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>和 get取得資料不同，利用 post 方法，傳送資料到伺服器，可以做帳號驗證、登入等功能。</p>
<p><img src="https://miro.medium.com/max/1155/1*4ip7E7cbry2cIWUcO1Ufvg.png" alt="post"></p>
<ol>
<li>open方法，選用post</li>
<li>setRequestHeader，指定傳送資料的格式</li>
</ol>
<ul>
<li>json : application&#x2F;json</li>
<li>傳統表單: application&#x2F;x-www-form-urlencoded</li>
</ul>
<ol start="3">
<li><p>send 傳送要核對的資料 ，利用 &amp; 連接多筆資料</p>
</li>
<li><p>監聽 onload事件，處理回傳後資料</p>
</li>
</ol>
<p><img src="https://miro.medium.com/max/1086/1*RSI2A1RPc5obLx5K_sYEyQ.png" alt="onload"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax解說系列(4) Axios 套件</title>
    <url>/2022/07/01/2022-7-1-4-js-axios/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>除了使用 fetch這種原生api來處理AJAX以外，我們也可以使用套件來處理，本文介紹的axios即是處理ajax可用的套件。</p>
<h2 id="axios基本語法"><a href="#axios基本語法" class="headerlink" title="axios基本語法"></a>axios基本語法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(url[,config])</span><br></pre></td></tr></table></figure>

<p>axios回傳的是一個promise，所以我們可以用 <code>.then() .catch()</code> 來接收結果。</p>
<h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://example/api/&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>( <span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response))</span><br><span class="line">    .<span class="title function_">catch</span>( <span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error));</span><br></pre></td></tr></table></figure>

<p>用 axios.get(‘資源網址’) 即可發出get請求。</p>
<p>也可加入參數，参數放在params屬性裏面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://example/api/&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">gender</span>: <span class="string">&#x27;female&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br></pre></td></tr></table></figure>

<h2 id="post-方法"><a href="#post-方法" class="headerlink" title="post 方法"></a>post 方法</h2><p><img src="https://miro.medium.com/max/1155/1*wUR2CLqYOBdpxogkcB-5aA.png" alt="post"><br><img src="https://miro.medium.com/max/1155/1*pwaLtrNzCstPuhKF9p6Spg.png" alt="post"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(‘api網址’ , 物件格式資料)</span><br></pre></td></tr></table></figure>
<p>用.then接收成功資訊，.catch()接收失敗資訊</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Ajax</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>(3)  Node.js Global全域物件</title>
    <url>/2022/07/11/2022-7-11-2-node-global/</url>
    <content><![CDATA[<h2 id="Global-全域物件"><a href="#Global-全域物件" class="headerlink" title="Global 全域物件"></a>Global 全域物件</h2><p>在js中有 window 這個全域物件，我們可以將變數賦予到window上存取，我們稱為全域變數。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071103.png?alt=media&token=e0e1c0f6-8781-4730-b61b-7361b9e60446" alt="window"></p>
<p>在 node.js中也有 Global 全域物件，我們將 global console出來會發現global內也有許多預設的功能。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071105.png?alt=media&token=8fe2bec8-2284-4917-a8a5-487630b0eb4e" alt="global"></p>
<h2 id="在global上新增變數"><a href="#在global上新增變數" class="headerlink" title="在global上新增變數"></a>在global上新增變數</h2><p>和window一樣，我們也可將變數賦予到 global 上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">global</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>

<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071106.png?alt=media&token=9c5107fe-7d60-4bdc-aa03-701075ff6d83" alt="a賦予到 global"></p>
<h2 id="global的變數作用域"><a href="#global的變數作用域" class="headerlink" title="global的變數作用域"></a>global的變數作用域</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071107.png?alt=media&token=4129e4f2-53df-4ec2-a84b-8a77b3080717" alt="變數作用域"></p>
<p>在每隻js裡宣告的變數，只會在那隻js裡有效，無法在global內被存取。如果想存取到global上，要寫 <code>global.a = 1</code> 的方式。這和在winddow能直接繼承用var宣告的變數不同。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>(2) 透過 Node.js 執行 JS 檔案</title>
    <url>/2022/07/11/2022-7-11-1-node-run/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇我們已經將 Node.js 安裝好了，這章節就小試身手，來用 Node.js 執行檔案吧。</p>
<h2 id="新增js檔案"><a href="#新增js檔案" class="headerlink" title="新增js檔案"></a>新增js檔案</h2><p>我們先在桌面新增一個project資料夾，並在裡面新增一隻app.js檔案。新增後，我們用vscode編輯器開啟該資料夾。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071101.png?alt=media&token=58b8f450-806a-4c33-bafe-b23e4a61353e" alt="project"></p>
<h2 id="執行js檔案"><a href="#執行js檔案" class="headerlink" title="執行js檔案"></a>執行js檔案</h2><p>檔案開啟後，我們就可用node.js來執行它，開啟終端機並輸入:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node app.<span class="property">js</span></span><br></pre></td></tr></table></figure>

<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071102.png?alt=media&token=9980edd6-0205-420e-9705-26810cb3818a" alt="執行js檔案"></p>
<p>執行後就可看到終端機順利輸出 console.log的結果囉。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>(4) Node.js require、module exports 模組設計</title>
    <url>/2022/07/11/2022-7-11-3-node-export-import/</url>
    <content><![CDATA[<h2 id="匯入匯出"><a href="#匯入匯出" class="headerlink" title="匯入匯出"></a>匯入匯出</h2><p>在node.js如果想讀取或匯出不同js檔案的資料，可用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = data;  <span class="comment">// 匯出資料</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">require</span>(<span class="string">&#x27;./data&#x27;</span>);  <span class="comment">// 匯入資料</span></span><br></pre></td></tr></table></figure>

<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071108.png?alt=media&token=d3064ea4-4ab5-43a0-b915-1a5a5d20a434" alt="匯入匯出"></p>
<p>如上圖，我們在 data.js裡用module.exports匯出資料，並在 app.js裡用 require 匯入。</p>
<h2 id="匯出整筆物件"><a href="#匯出整筆物件" class="headerlink" title="匯出整筆物件"></a>匯出整筆物件</h2><p>若有多筆資料要同時匯出，也可將資料放到物件裡同時匯出:</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071109.png?alt=media&token=d4e53e3c-1b7a-4ec8-b8ed-8e095399cd7d" alt="匯出物件"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>(6) Node.js 內建模組</title>
    <url>/2022/07/11/2022-7-11-5-node-module/</url>
    <content><![CDATA[<h2 id="OS模組-operating-system模組"><a href="#OS模組-operating-system模組" class="headerlink" title="OS模組(operating system模組)"></a>OS模組(operating system模組)</h2><p>os 提供了一些基本的系统操作函数，首先載入模組</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/942/1*N07WqfVXhpTjXTv7Tc1TSA.png" alt="os"></p>
<p><img src="https://miro.medium.com/max/982/1*VhskxuDYl8iPxJWp8vrKcA.png" alt="os"></p>
<p>上圖中顯示 userInfo和 uptime</p>
<p><img src="https://miro.medium.com/max/954/1*gUiWv1LYXUv5DWUh3zdlvg.png" alt="os"></p>
<p><img src="https://miro.medium.com/max/786/1*HDXgZT45S93ydYeiIPVnIA.png" alt="os"></p>
<p>上圖顯示，使用者系統名稱如windows和相關記憶體資料。</p>
<h2 id="Path模組"><a href="#Path模組" class="headerlink" title="Path模組"></a>Path模組</h2><p>再講 path模組前，先介紹兩個功能 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">__dirname : 回傳檔案目錄位置</span><br><span class="line">__filename : 回傳檔案目錄位置(包含檔名)</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071114.png?alt=media&token=e85ea62f-4e45-47fe-8746-55740d27bc8f" alt="__dirname，__filename"></p>
<p>nodeJs裡有一個 path 模組，可用來取得檔案與目錄路徑，詳細也可瀏覽 <a href="https://nodejs.org/api/path.html">Node.js PATH API文件</a></p>
<ul>
<li>抓目錄路徑： path.dirname(‘&#x2F;xx&#x2F;yy&#x2F;zz.js’) 回傳 &#x2F;xx&#x2F;yy</li>
<li>路徑合併：path.join(__dirname,’&#x2F;xx’) 回傳 前後路徑合併</li>
<li>抓檔名： path.basename(‘&#x2F;xx&#x2F;yy&#x2F;zz.js’) 回傳 zz.js</li>
<li>抓副檔名： path.extname(‘&#x2F;xx&#x2F;yy&#x2F;zz.js’) 回傳 js</li>
<li>分析路徑： path.parse(‘&#x2F;xx&#x2F;yy&#x2F;zz.js’) 回傳 上述綜合物件</li>
</ul>
<h3 id="絕對路徑-path-resolve"><a href="#絕對路徑-path-resolve" class="headerlink" title="絕對路徑: path.resolve()"></a>絕對路徑: path.resolve()</h3><p>path.resolve()方法用於將path-segments序列解析為絕對路徑。它通過處理從右到左的路徑順序來工作，在每個路徑之前添加，直到創建絕對路徑為止。</p>
<p><img src="https://miro.medium.com/max/1400/1*RzS_lXFO03QUo1fP5D5xkA.png" alt="path"></p>
<p><img src="https://miro.medium.com/max/1400/1*2Yq7Z3y8Dh5AGiDVMvvBWA.png" alt="path"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>(5) Node.js 內建模組 createServer</title>
    <url>/2022/07/11/2022-7-11-4-node-createServer/</url>
    <content><![CDATA[<h2 id="內建模組-createServer"><a href="#內建模組-createServer" class="headerlink" title="內建模組 createServer"></a>內建模組 createServer</h2><p>在 node.js 中有許多內建模組，其中 createServer 可以用來開啟個web伺服器。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071110.png?alt=media&token=7ce0ed04-70e6-405b-99c2-fab0e7782e73" alt="createServer"></p>
<p>上圖中，我們用<code>require(&#39;http&#39;)</code>，將http模組引入。引入後，用http模組的createServer功能開啟伺服器。並在createServer()裡帶入一個函式，並傳入兩個參數 request， response。</p>
<ul>
<li>request: 代表前端發出的請求的詳細資訊</li>
<li>response: 代表伺服器要回傳的資料</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071111.png?alt=media&token=db5e0f66-5d26-473d-a617-3ab8cd50d137" alt="req, res"></p>
<p>我們用 response.writeHead()撰寫表頭資料，response.write()寫回傳的內容，response.end()代表結束。最後用listen()來監聽port。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(1) 開啟web伺服器</title>
    <url>/2022/07/11/2022-7-11-6-node-express-1/</url>
    <content><![CDATA[<h2 id="什麼是Express"><a href="#什麼是Express" class="headerlink" title="什麼是Express?"></a>什麼是Express?</h2><p>Express 這個套件主要幫忙解決許多node.js http server 所需要的基本服務，讓開發http service 變得更為容易，不需要像之前需要透過層層模組（module）才有辦法開始編寫自己的程式。</p>
<p>這個套件是由TJ Holowaychuk 製作而成的套件，裡面包含基本的路由處理(route)，http 資料處理（GET&#x2F;POST&#x2F;PUT），另外還與樣板套件（js html template engine）搭配，同時也可以處理許多複雜化的問題。</p>
<h2 id="安裝express"><a href="#安裝express" class="headerlink" title="安裝express"></a>安裝express</h2><p>在新專案裡 輸入 npm init 建立 package.json檔後，輸入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install express --save   // 安裝express 套件</span><br></pre></td></tr></table></figure>

<h2 id="建立web伺服器"><a href="#建立web伺服器" class="headerlink" title="建立web伺服器"></a>建立web伺服器</h2><p><img src="https://miro.medium.com/max/1400/1*-a7Jvq3IudAqXHKVJYVXKQ.png" alt="app.js"></p>
<p>在js檔裡，先把express require()進來，並將express賦予到app變數上。</p>
<p>app.get: 第一個參數是路由，看前端是訪問哪個網址，第二個function則帶入req, res參數。</p>
<p>app.listen: 監聽個別的port。</p>
<h2 id="404頁面設計"><a href="#404頁面設計" class="headerlink" title="404頁面設計"></a>404頁面設計</h2><p><img src="https://miro.medium.com/max/1236/1*WcOY6fVxz7hTrTSOot1xyQ.png" alt="404頁面"></p>
<p>使用app.all(‘*’)來設計404頁面，不論使用者是發出 get 、post 、put 、delete請求，都會觸發app.all。並且使用 * 做為路由，代表不管使用者前往哪個路由都會觸發這個function。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(4) Middleware</title>
    <url>/2022/07/12/2022-7-12-1-node-middleware/</url>
    <content><![CDATA[<h2 id="Middleware-概念"><a href="#Middleware-概念" class="headerlink" title="Middleware 概念"></a>Middleware 概念</h2><p>Middleware 像水管一樣可以串聯在一起，所有的 Request 及 Response 都會層層經過這些水管。<br>用圖例可以很容易理解，如下圖：</p>
<p><img src="https://miro.medium.com/max/1200/0*6JyVusGg4jQkcBJw.png" alt="middleware"></p>
<h2 id="App-use"><a href="#App-use" class="headerlink" title="App.use"></a>App.use</h2><p>在express中，使用app.use作為類似守門員的角色，app.use就像一層一層的水管，當程式符合條件，才會執行next()，進到下一個funciton。</p>
<p><img src="https://miro.medium.com/max/1400/1*ZG8cv5Yke-HB8ZdEx0oUoQ.png" alt="app.use"></p>
<h2 id="404路由設定"><a href="#404路由設定" class="headerlink" title="404路由設定"></a>404路由設定</h2><p><img src="https://miro.medium.com/max/1400/1*tdatSPLTGHYNUeRLNnEzNA.png" alt="404"></p>
<p>當今天使用者輸入錯誤網址，應該要回傳404頁面。像上圖，當使用者輸入 &#x2F;user ，那沒問題會進入user頁面。</p>
<p>但如果輸入錯誤，可以使用app.use，來回傳res.status(404)，並且send一個404提示頁面給使用者看。如果是程式有問題則可回傳res.status(500)。</p>
<h2 id="middleware-位置"><a href="#middleware-位置" class="headerlink" title="middleware 位置"></a>middleware 位置</h2><p>middleware寫的位置也可不同，以下介紹不同的寫法:</p>
<h3 id="寫在參數內"><a href="#寫在參數內" class="headerlink" title="寫在參數內"></a>寫在參數內</h3><p>middleware也可以寫在路由函式的第二個參數，當使用者進入’&#x2F;user’後，就會進入守門員 middleware，當通過next()後，才會跑最後的function。</p>
<p><img src="https://miro.medium.com/max/1400/1*eIOZrfAsK9x2Ey328D1wxQ.png" alt="寫在第二個參數"></p>
<h3 id="加入多個middleware"><a href="#加入多個middleware" class="headerlink" title="加入多個middleware"></a>加入多個middleware</h3><p>加入多個middleware，可以用陣列方式</p>
<p><img src="https://miro.medium.com/max/1400/1*9IjEP7363kE6HV1ZgHI8GA.png" alt="多個middleware"></p>
<h3 id="加入所有router"><a href="#加入所有router" class="headerlink" title="加入所有router"></a>加入所有router</h3><p>上圖中，我們是手動將logger加入路由中，但當今天路由很多時，無法一一加入，可以用app.use(middleware)，一次將middleware加入所有頁面。</p>
<p><img src="https://miro.medium.com/max/1400/1*-18WRu76rnoT2zAaDQyObw.png" alt="加入所有router"></p>
<p>當有多個middleware要加入時，可以用陣列方式加入，陣列裡的順序會影響middleware的執行順序。</p>
<p><img src="https://miro.medium.com/max/1328/1*QXP-U-OUPfYuBOMyqT9B8Q.png" alt="加入多個"></p>
<h3 id="加入指定路徑的路由"><a href="#加入指定路徑的路由" class="headerlink" title="加入指定路徑的路由"></a>加入指定路徑的路由</h3><p><img src="https://miro.medium.com/max/948/1*tArClOuxGOqWKeursFf5NQ.png"></p>
<p>app.use()，第一個參數可加入指定路徑，如上圖只要路徑是&#x2F;api開頭的都會被加上middleware，如 &#x2F;api&#x2F;about、&#x2F;api&#x2F;products</p>
<p><img src="https://miro.medium.com/max/1216/1*H0R6d3NsPCX423vN5NZT3A.png"></p>
<h2 id="express內建-middleware"><a href="#express內建-middleware" class="headerlink" title="express內建 middleware"></a>express內建 middleware</h2><p>在express中，已經內建了許多 middleware，如之前學過的express.static()</p>
<p><img src="https://miro.medium.com/max/908/1*eQ0DKpqLRQ2rIXcShoOwxg.png"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(3) 路由設計</title>
    <url>/2022/07/11/2022-7-11-8-node-route/</url>
    <content><![CDATA[<h2 id="設計路由-固定路徑"><a href="#設計路由-固定路徑" class="headerlink" title="設計路由(固定路徑)"></a>設計路由(固定路徑)</h2><p><img src="https://miro.medium.com/max/1400/1*dZ1tIxswvDQ40zTICPcpUg.png" alt="路由"></p>
<p>我們可以設計像 ‘&#x2F;user&#x2F;edit-photo’、’&#x2F;user&#x2F;edit-profile’ 不同的路由，讓使用者來到user頁面後再去不同的頁面如edit-photo、edit-profile。</p>
<h2 id="動態路由"><a href="#動態路由" class="headerlink" title="動態路由"></a>動態路由</h2><p><img src="https://miro.medium.com/max/1400/1*-X6TxEjNyQ0DPy5IMtVwaA.png" alt="動態路由"></p>
<p>有時候會在網址路徑後看到一串亂碼，那串亂碼就是專屬的序號內容，利用這個序號內容去資料庫撈出對應的資料。</p>
<h2 id="取得動態路徑"><a href="#取得動態路徑" class="headerlink" title="取得動態路徑"></a>取得動態路徑</h2><p><img src="https://miro.medium.com/max/1400/1*zxg6lOzZWL8c3ijWK-i7rw.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/route/:params  指定動態路由</span><br><span class="line">req.params  取得動態路由</span><br></pre></td></tr></table></figure>

<p>如上圖我指定動態路由是&#x2F;:name，就可以用req.params.name將動態路由的值撈出來去資料庫做判斷。</p>
<p><img src="https://miro.medium.com/max/1400/1*FSy3X_0YLDQWpzgGslbdPg.png"></p>
<p>路由裡也可以有多組params，如上圖我有 &#x2F;:productID和 &#x2F;:reviewID兩組params，req.params回傳後是一個物件，裡面是各個params的值。</p>
<p><img src="https://miro.medium.com/max/990/1*DMxLXRpjJ1FHZjHqTcjrhg.png"></p>
<h2 id="query-—-取得網址參數"><a href="#query-—-取得網址參數" class="headerlink" title="query — 取得網址參數"></a>query — 取得網址參數</h2><p><img src="https://miro.medium.com/max/1400/1*2igJn3maJXQnHbDaxlIjlA.png"></p>
<p><img src="https://miro.medium.com/max/816/1*IBO0l0IXCUR2NpMfQ-ixYg.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.query.參數名稱   取得參數的值</span><br></pre></td></tr></table></figure>

<p>在網址中?後方代表的是query參數，在express中，可以用 req.query.參數名稱，來取得參數的值。</p>
<h3 id="query範例"><a href="#query範例" class="headerlink" title="query範例"></a>query範例</h3><p><img src="https://miro.medium.com/max/1002/1*uLDTt5JDg1HpufIpz_J9AQ.png"></p>
<p><img src="https://miro.medium.com/max/1400/1*si0clmAdnnJYOxd-dnBBOA.png"></p>
<p>上面範例中，先將 search跟 limit 從req.query解構出來後，再利用if判斷 search跟limit有沒有值，有的話就用search跟limit做資料過濾。</p>
<p>如果過濾完沒有值，就回傳空陣列，有值則回傳過濾後陣列。要注意 res回傳只能有一個，所以 前面判斷後的res要加上return。</p>
<h2 id="路由模組化"><a href="#路由模組化" class="headerlink" title="路由模組化"></a>路由模組化</h2><p>為了將不同頁面的路由做模組化，可以先新增一個routes資料，裏頭放不同頁面的路由，例如我有一個user頁面的路由。</p>
<p><img src="https://miro.medium.com/max/784/1*x1CvqoWfVU-tyqLdd4pvvA.png"></p>
<p><img src="https://miro.medium.com/max/1400/1*o2HfO91SWYAhQT_quM6pfg.png"></p>
<p>在user.js裡，可以先載入express.Router()這個模組。利用這個模組，去接分頁的路由。</p>
<p><img src="https://miro.medium.com/max/1400/1*U_m027G0wE2o4rhvsuKJGQ.png"></p>
<p>在app.js中，可以將’.&#x2F;routes&#x2F;user’引入，再用app.use載入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user&#x27;</span>, user)，<span class="comment">// 使用者造訪/user時，就會去user模組裡載入對應的路由。</span></span><br></pre></td></tr></table></figure>

<h3 id="function-拆分"><a href="#function-拆分" class="headerlink" title="function 拆分"></a>function 拆分</h3><p>更進一步，我們可以將 routes裡的function再拆分出來到 controllers 資料夾<br><img src="https://miro.medium.com/max/714/1*RaxVzLnFqPCea4SL4msVqQ.png"></p>
<p><img src="https://miro.medium.com/max/1400/1*n_Ji23Gxgq7a-GN9VRW9vQ.png"></p>
<p>在 people.js中，我將路由的callback function拆分出來，在用module.exports一次export出去。</p>
<p><img src="https://miro.medium.com/max/1400/1*lT4RKWhgu8Kka-jH1ueqdQ.png"></p>
<p>在 路由的 js檔中，再將這些方法 require 進來。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(5) 靜態檔案</title>
    <url>/2022/07/12/2022-7-12-2-node-static/</url>
    <content><![CDATA[<h2 id="設定靜態檔案"><a href="#設定靜態檔案" class="headerlink" title="設定靜態檔案"></a>設定靜態檔案</h2><p>靜態檔案泛指瀏覽器在呈現完整畫面時所需要的資源檔案，指的是伺服器端不需要去改變的檔案。<br>常見有的.js、.css、.jpg、.png等</p>
<p>在express中如果要載入靜態檔案如圖片、css檔案等，要在程式碼前面先指定靜態檔路徑: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>上面程式中，我們將靜態檔案設定在public資料夾裡，這樣之後的靜態檔路徑就會從public開始抓</p>
<p><img src="https://miro.medium.com/max/1400/1*kn1VKZekT892LH8V5YZsvg.png"></p>
<p>如上圖會去找&#x2F;public&#x2F;images&#x2F;logo.png</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(2) 網址規則</title>
    <url>/2022/07/11/2022-7-11-7-node-network/</url>
    <content><![CDATA[<h2 id="網址的組成"><a href="#網址的組成" class="headerlink" title="網址的組成"></a>網址的組成</h2><p><img src="https://miro.medium.com/max/1400/1*IeJWJEhLIuP0HUfUKMcPgA.png" alt="網址組成"></p>
<p><img src="https://miro.medium.com/max/1400/1*QuRd_DEPJoO76rLIFYklQw.png" alt="https"></p>
<p>https相較http協定，因為有加密是較安全的。</p>
<p><img src="https://miro.medium.com/max/1400/1*324Ulsn-ffPuzx9EX1eMwg.png" alt="網域"></p>
<p>購買好主網址後，次網域可以依據不同服務掛在主網域下。</p>
<p><img src="https://miro.medium.com/max/1400/1*mXxjTDg-yFBJUeKlT2zo4g.png" alt="參數"></p>
<p>在路徑search之後，可以設置query也就是參數，傳到後端後會解析成物件格式，再用這個物件去資料庫撈出對應資料。參數可以有多個，彼此用 &amp; 符號連接。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(6) EJS樣板語言</title>
    <url>/2022/07/13/2022-7-13-1-ejs-install/</url>
    <content><![CDATA[<h2 id="EJS-介紹"><a href="#EJS-介紹" class="headerlink" title="EJS 介紹"></a>EJS 介紹</h2><p>EJS 的全名是「Embedded Javascript」，顧名思義就是內嵌式的樣板引擎，可以將邏輯與內容直接嵌入到 HTML 頁面上，也就是 EJS 可以讓我們利用 JavaScript 生成 HTML 頁面 。</p>
<h2 id="替-Express-加入-EJS"><a href="#替-Express-加入-EJS" class="headerlink" title="替 Express 加入 EJS"></a>替 Express 加入 EJS</h2><p>首先要先來安裝 EJS 套件進入專案，這邊選用 <a href="https://www.npmjs.com/package/ejs-locals">ejs-locals</a> 這個鄉民開發的套件，因為正版ejs有些功能較缺乏。</p>
<p><img src="https://miro.medium.com/max/1400/1*gfvzeVND9wZ-5HET2qaaKg.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">engine</span>() <span class="comment">// 指定我們要用的樣板引擎是ejs。</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;views&#x27;</span>, <span class="string">&#x27;./views&#x27;</span>)  <span class="comment">//設定views資料夾，存放所有ejs樣板檔案。</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>) <span class="comment">// 告訴express要用ejs樣板來跑。</span></span><br></pre></td></tr></table></figure>

<h2 id="新增-ejs-檔案"><a href="#新增-ejs-檔案" class="headerlink" title="新增 ejs 檔案"></a>新增 ejs 檔案</h2><p><img src="https://miro.medium.com/max/788/1*GVlx6DfG7W4l9SMN9UOcAg.png"></p>
<p><img src="https://miro.medium.com/max/1400/1*q-nTWNurcyFK6D3LeObr6w.png"></p>
<p>在view資料夾下，新增不同頁面的 ejs檔案。</p>
<p><img src="https://miro.medium.com/max/1400/1*RvhXzYdnc6cshoJ3NhS3Zg.png"></p>
<p>在app.get裡，可以用res.render()來指定要渲染的ejs檔案，這邊不用加副檔名.ejs，因為在app.set時已經指定渲染樣板為ejs。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(7) EJS Layout</title>
    <url>/2022/07/13/2022-7-13-2-ejs-layout/</url>
    <content><![CDATA[<h2 id="設定樣板"><a href="#設定樣板" class="headerlink" title="設定樣板"></a>設定樣板</h2><p>我們可以新增一個 layout.ejs 作為樣板頁面使用，layout裡加入 <code>&lt;%- body %&gt;</code> 語法，會將其他ejs檔內容匯入。</p>
<p><img src="https://miro.medium.com/max/1400/1*HCMrT2xXSlDbGgThg-E0FA.png"></p>
<p>在其他ejs上，只須加上一行 <code>&lt;% layout(&#39;樣板檔案名稱&#39;) %&gt;</code>，就可將樣板帶入。</p>
<p><img src="https://miro.medium.com/max/930/1*uI6xlmXBCNH-7o0Ro_NxFg.png"></p>
<h2 id="路由導入參數"><a href="#路由導入參數" class="headerlink" title="路由導入參數"></a>路由導入參數</h2><p><img src="https://miro.medium.com/max/1320/1*n9MNv2VOt634BqoBPeFmTw.png"></p>
<p>在res.render裡面第一個參數是指定ejs樣板，第二個參數則可帶入一個物件，裡頭是要選染的變數資料。</p>
<p><img src="https://miro.medium.com/max/1400/1*MEchuM--HhsuN16kiVua_g.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%= 變數名稱 %&gt;  // 將參數當作純字串渲染</span><br><span class="line">&lt;%- 變數名稱 %&gt;  // 將參數當作html渲染</span><br></pre></td></tr></table></figure>

<h2 id="流程判斷"><a href="#流程判斷" class="headerlink" title="流程判斷"></a>流程判斷</h2><p>在ejs裡，也可加入if else的判斷，假設我有一個show的變數</p>
<p><img src="https://miro.medium.com/max/1090/1*g2OO40_Q_po6b1qZW3PEGw.png"></p>
<p>在ejs裡一樣可以用 &lt;% %&gt;在裏頭寫邏輯判斷</p>
<p><img src="https://miro.medium.com/max/908/1*SJVRG_Rem5uq7Aihpgb_Mw.png"></p>
<p>假設show是true則渲染內容，false則不渲染。</p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>ejs也可以渲染陣列，假設有一個course陣列如下:</p>
<p><img src="https://miro.medium.com/max/1108/1*eqFjWH00H2lzsN12qE2sTw.png"></p>
<p>在ejs裡一樣可以用 for 語法去渲染陣列出來</p>
<p><img src="https://miro.medium.com/max/1152/1*TWV9_MNkwNTjiJcBaz2Q4Q.png"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman-API 管理工具</title>
    <url>/2022/07/13/2022-7-13-3-postman/</url>
    <content><![CDATA[<h2 id="什麼是postman"><a href="#什麼是postman" class="headerlink" title="什麼是postman?"></a>什麼是postman?</h2><p>Postman 是一個可以模擬 HTTP Request 的工具，其中包含常見的 HTTP 的請求方式，例如： GET 、POST、PUT、DELETE，而它的主要功能就是能夠快速的測試你的 API 是否能夠正常的請求資料，並得到正確的請求結果。</p>
<h2 id="安裝程式"><a href="#安裝程式" class="headerlink" title="安裝程式"></a>安裝程式</h2><p>首先來 <a href="https://www.postman.com/downloads/">postman官網</a> 下載postman程式。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071301.png?alt=media&token=11df68e4-e1e5-49a5-9bb6-86811c4c9aae" alt="postman"></p>
<h2 id="基礎操作"><a href="#基礎操作" class="headerlink" title="基礎操作"></a>基礎操作</h2><p>開啟postman程式後，左側是我們的放專案資料夾的區域，每個資料夾裡可以新增該專案要測試的api。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071302.png?alt=media&token=9886dcd1-a663-44d5-bebe-c1cd8d07ff35"></p>
<p>可以新增 GET 、POST、PUT、DELETE 等不同請求的api進行測試。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071303.png?alt=media&token=9f647251-777b-4e37-861d-83ea5174168d"></p>
<h2 id="post-傳送表單資料"><a href="#post-傳送表單資料" class="headerlink" title="post 傳送表單資料"></a>post 傳送表單資料</h2><p>在postman裡，我們可以模擬前端表單發送資料。api方法選擇 POST，並在body輸入key跟value，其中key就相當於表單的name，value就是name的值，表單方法選擇 <code>x-www-form-urlencoded</code>。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071304.png?alt=media&token=2d840b29-a9b9-4280-8bf1-c2591e4abce9"></p>
<p>如果是向後端傳送 JSON格式，body裡選擇 raw ，格式選擇 JSON</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071305.png?alt=media&token=55812d07-a857-4c5f-b1a2-245ce2518337"></p>
]]></content>
      <categories>
        <category>Postman</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(9) express-generator</title>
    <url>/2022/07/14/2022-7-14-1-express-generator/</url>
    <content><![CDATA[<h2 id="安裝產生器"><a href="#安裝產生器" class="headerlink" title="安裝產生器"></a>安裝產生器</h2><p>我們可以用express 產生器快速建立一個nodeJs專案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install express-generator -g  // 安裝套件</span><br></pre></td></tr></table></figure>

<p>使用 -h 選項來顯示指令選項：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ express -h</span><br><span class="line">  Usage: express [options][dir]</span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --help          output usage information</span><br><span class="line">        --version       output the version number</span><br><span class="line">    -e, --ejs           add ejs engine support</span><br><span class="line">        --hbs           add handlebars engine support</span><br><span class="line">        --pug           add pug engine support</span><br><span class="line">    -H, --hogan         add hogan.js engine support</span><br><span class="line">        --no-view       generate without view engine</span><br><span class="line">    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)</span><br><span class="line">    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)</span><br><span class="line">        --git           add .gitignore</span><br><span class="line">    -f, --force         force on non-empty directory</span><br></pre></td></tr></table></figure>

<p>舉例來說，以下是在現行工作目錄中建立一個名為 myapp 的 Express 應用程式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ express --view=pug myapp</span><br><span class="line"></span><br><span class="line">   create : myapp</span><br><span class="line">   create : myapp/package.json</span><br><span class="line">   create : myapp/app.js</span><br><span class="line">   create : myapp/public</span><br><span class="line">   create : myapp/public/javascripts</span><br><span class="line">   create : myapp/public/images</span><br><span class="line">   create : myapp/routes</span><br><span class="line">   create : myapp/routes/index.js</span><br><span class="line">   create : myapp/routes/users.js</span><br><span class="line">   create : myapp/public/stylesheets</span><br><span class="line">   create : myapp/public/stylesheets/style.css</span><br><span class="line">   create : myapp/views</span><br><span class="line">   create : myapp/views/index.pug</span><br><span class="line">   create : myapp/views/layout.pug</span><br><span class="line">   create : myapp/views/error.pug</span><br><span class="line">   create : myapp/bin</span><br><span class="line">   create : myapp/bin/www</span><br></pre></td></tr></table></figure>

<p>然後安裝相依項目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd myapp</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>執行專案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(8) body-parser</title>
    <url>/2022/07/13/2022-7-13-4-body-parser/</url>
    <content><![CDATA[<h2 id="body-parser-是什麼？"><a href="#body-parser-是什麼？" class="headerlink" title="body-parser 是什麼？"></a>body-parser 是什麼？</h2><p>body-parser 是 Express 經常使用的中介軟體，用於解析請求的資料(body)，比如說：POST 一筆 JSON 格式的資料到我們的 Express App，這時可以透過 body-parser 快速解析這筆資料，以方便取用。下方的圖為 Express 的運作模型，可以看到 body-parser 會先進行資料的解析，才會把解析後的資料傳給其他相關的 middleware 使用。</p>
<p><img src="https://miro.medium.com/max/1400/0*8sAI6T1cahPoR-e6.png"></p>
<h2 id="使用-body-parser"><a href="#使用-body-parser" class="headerlink" title="使用 body-parser"></a>使用 body-parser</h2><p>在express4的版本已經內建body-parser的功能，所以直接使用即可:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());  <span class="comment">// 解析json格式</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;)); <span class="comment">// 解析表單資料</span></span><br></pre></td></tr></table></figure>

<h2 id="表單設計"><a href="#表單設計" class="headerlink" title="表單設計"></a>表單設計</h2><p><img src="https://miro.medium.com/max/1196/1*XUZu72p4jof3Tk6jZl6xOg.png"></p>
<p>在Form標籤上，action的路徑代標資料會傳到哪，method則選用post代表將資料送出到後端。</p>
<p><img src="https://miro.medium.com/max/1156/1*xn-Ao4WJiGUQEVJh2uRRDw.png"></p>
<p>在app.js中，可以設計app.post去接收前端表單的資料，第一個參數’&#x2F;searchList’ 也就是前端表單的action路徑。</p>
<p>接收到的req.body會是一個 json格式，key值就是前端input所指定的name。</p>
<h2 id="Redirect-跳轉頁面設定"><a href="#Redirect-跳轉頁面設定" class="headerlink" title="Redirect 跳轉頁面設定"></a>Redirect 跳轉頁面設定</h2><p><img src="https://miro.medium.com/max/1240/1*Ky3EZaP8KjIveIpTp7b7eA.png"></p>
<p>當我們收到前端傳來的表單資料後，並將資料處理完後，就可以用</p>
<p>res.redirect(‘路由’)將網頁導回 指定頁面。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB (一) 安裝MongoDB與基礎指令</title>
    <url>/2022/07/15/2022-7-15-1-mongodb-install/</url>
    <content><![CDATA[<h2 id="MongoDB是什麼"><a href="#MongoDB是什麼" class="headerlink" title="MongoDB是什麼?"></a>MongoDB是什麼?</h2><p>MongoDB 是一個開源的「NoSQL ( 非關聯性 ) 文件資料庫」，具有以下優點:</p>
<ul>
<li>不須先創立數據表格，且數據格式自由<br>MySQL 須創建表格讓 MySQL 抓取數據，而 MongoDB 不需事先創建表格，也能將數據直接寫入並彈性添加欄位，且欄位的格式較自由，例如:欄位使用數字或是字符串皆可。</li>
<li>可以處理json結構<br>MongoDB 將資料儲存為文件（類似 JSON 物件），以 field-value 為結構成對儲存，value 可以包含值、文件、陣列、文件陣列，讀取欄位內的數值。</li>
</ul>
<h2 id="安裝MongoDB"><a href="#安裝MongoDB" class="headerlink" title="安裝MongoDB"></a>安裝MongoDB</h2><p>到<a href="https://www.mongodb.com/docs/manual/administration/install-community/">此網站</a> 安裝mongoDB</p>
<p><img src="https://miro.medium.com/max/1400/1*FCigXxB4Kis3PZ85fq2xiw.png"></p>
<p>到<a href="https://www.mongodb.com/docs/mongodb-shell/install/">此網站</a> 安裝 mongosh(連線到mongoDB會用到的工具)</p>
<p><img src="https://miro.medium.com/max/1400/1*pLlEilk0USrVukdgBbCKug.png"></p>
<p>安裝好後，打開終端機輸入 mongosh，會顯示目前安裝的mongoDB版本。</p>
<p><img src="https://miro.medium.com/max/1400/1*_2EgvYu5TghFeA6_a7R2hw.png"></p>
<h2 id="基礎指令"><a href="#基礎指令" class="headerlink" title="基礎指令"></a>基礎指令</h2><p><code>show dbs </code>: 顯示目前有的資料庫</p>
<p><img src="https://miro.medium.com/max/604/1*ZY3KbCmUBn6qjpZSbP1UYw.png"></p>
<p><code>use 資料庫名稱</code>: 新增資料庫</p>
<p><img src="https://miro.medium.com/max/640/1*8sW3YtdIxNhjE7ItSA-mCQ.png"></p>
<p><code>show collections</code> : 顯示資料庫裡的collections</p>
<p><code>db.dropDatabase()</code> : 刪除目前資料庫</p>
<p><img src="https://miro.medium.com/max/840/1*bwoP97w5Dk7fMWbJBF8PUA.png"></p>
<p><code>cls</code> : 清除終端機指令</p>
<p><code>exit</code> : 離開mongosh，回到終端機</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>NPM 使用教學</title>
    <url>/2022/07/14/2022-7-14-2-npm/</url>
    <content><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/1320/0*Mjnr9OEpIH64xV8m.png"></p>
<h2 id="什麼是npm"><a href="#什麼是npm" class="headerlink" title="什麼是npm?"></a>什麼是npm?</h2><p>npm 是Node Package Manager的縮寫，是一個線上套件庫，讓我們透過指令的方式去安裝需要的檔案到專案裡使用。</p>
<h2 id="安裝npm"><a href="#安裝npm" class="headerlink" title="安裝npm"></a>安裝npm</h2><p>既然npm是node.js的套件管理工具，首先我們就需要到node.js官網下載node.js(選擇 LTS穩定版)。當你安裝nodeJS的同時，NPM也會同時被安裝。詳細安裝方法<a href="https://tim8076.github.io/2022/07/10/2022-07-10-1-nodeJs-install/">參考這裡</a></p>
<h2 id="建立package-json檔案"><a href="#建立package-json檔案" class="headerlink" title="建立package.json檔案"></a>建立package.json檔案</h2><p>我們首先要建立的package.json的檔案在專案裡，目的是為了管理專案內的套件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init  //建立 package.json</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn-images-1.medium.com/max/1320/1*D0qqruBiUbjA5pnzkbL0hQ.png"></p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*ioKKlwAHawuNQX0fv1Yrzg.png"></p>
<p>之後當有其他人下載你的專案，想要使用這些套件時，只要輸入 npm install就會將套件全部下載回來。</p>
<h2 id="使用npm安裝套件"><a href="#使用npm安裝套件" class="headerlink" title="使用npm安裝套件"></a>使用npm安裝套件</h2><h3 id="全域安裝"><a href="#全域安裝" class="headerlink" title="全域安裝"></a>全域安裝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g 套件名稱</span><br></pre></td></tr></table></figure>
<p>套件會被安裝在電腦裡，每個專案資料夾都可使用該套件。通常會安裝到全域的套件是必須在commend line執行的，像是gulp-cli。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*b_n3XJStqP3dsnAAYawVKw.png"></p>
<h3 id="專案安裝"><a href="#專案安裝" class="headerlink" title="專案安裝"></a>專案安裝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install 套件名稱</span><br></pre></td></tr></table></figure>
<p>套件只會在該專案資料夾裡被安裝，每個專案資料夾都有不同的套件。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*fuj2s-0Ryq9p4fzdjSdwSQ.png"></p>
<h3 id="指令參數"><a href="#指令參數" class="headerlink" title="指令參數"></a>指令參數</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install 套件名稱 --save </span><br></pre></td></tr></table></figure>
<p><code>--save</code> 參數是安裝套件時，也同步更新 package.json 裡的資訊，正式產品會用到的套件請用–save。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install 套件名稱 - save-dev</span><br></pre></td></tr></table></figure>

<p>在指令最後加入<code>--save-dev</code>，套件會被安裝到devDependencies，代表此套件是開發過程才會用到，正式產品不會。</p>
<h3 id="mac指令"><a href="#mac指令" class="headerlink" title="mac指令"></a>mac指令</h3><p>如果是mac電腦， 請加上 sudo npm install 來安裝套件，因為mac需要更高的管理者權限來安裝。</p>
<h2 id="node-modules-資料夾"><a href="#node-modules-資料夾" class="headerlink" title="node-modules 資料夾"></a>node-modules 資料夾</h2><p>當你使用 npm 下載套件後，會發現有一個叫做 node-modules的資料夾產生了。這個資料夾的用途是儲存所有你用npm 下載下來的套件。<br>此時你可能會懷疑，為什麼我明明只下載了一個套件，但卻多出一堆我沒看過的套件。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*urQrPkezqbJUFXLz-Nzr9w.png"></p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*6RpLQLKnxZkO9XrE8CAtGA.png"></p>
<p>這是因為我們下載的套件，本身也有一個package.json，它也有依賴其他的套件，所以會一併將依賴的套件載入。所以每個套件都有其他相依套件，npm會將他們全部載回。</p>
<h2 id="npm-套件版本"><a href="#npm-套件版本" class="headerlink" title="npm 套件版本"></a>npm 套件版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm view 套件名稱 versions  // 查看套件版本</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*7MHtEBy6zJJQN25pe8bZeA.png"></p>
<p>套件採用 semantic versioning的版本管理方式，所以我們會看到 1.0.2 類似這種三個數字的版本號顯示，其實每個數字有代表不同的意思。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*JlYHyz5Pp1oJ_0b4RPDpNw.png"></p>
<ol>
<li>major (主版號) : 當套件做了重大更新，會不相容之前版本，可能讓你的舊版本的程式碼無法，要讓程式碼運作，要將舊版的code修改為新版寫法。</li>
<li>Minor version (次版號) : 做了一些可以向下兼容的功能性新增</li>
<li>Patch version: 修正一些小錯誤。</li>
</ol>
<h2 id="套件更新"><a href="#套件更新" class="headerlink" title="套件更新"></a>套件更新</h2><p>當你用npm intall安裝套件時，npm會自動下載最新版的套件，在你的package.json，可以看到套件版本號。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*YCOUexX0fPMAWVoWgvXGIw.png"></p>
<p>你可能注意到，每個版本號前多了一個 ^ 符號，這是npm用來避免你將套件更新到下一個主版號，造成你很多程式碼壞掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install 套件名稱 @lastest  // 更新到下一個主要版本</span><br></pre></td></tr></table></figure>

<p>但如果你的套件確定要更新到下一個主要版本，如 4.9.0 &#x3D;&gt; 5.0.0， 可以輸入 npm install 套件名稱 @lastest。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install 套件名稱@版本號</span><br></pre></td></tr></table></figure>

<p>指定安裝套件的版本號</p>
<h2 id="package-lock-json檔案"><a href="#package-lock-json檔案" class="headerlink" title="package-lock.json檔案"></a>package-lock.json檔案</h2><p>你可能會注意到，除了package.json以外，還有一個package-lock.json檔案。這個檔案紀錄了你安裝到專案的套件的詳細版本號，目的是為了避免相容性問題。還記得^ 這個符號嗎，當你從github clone一個別人的專案下來，並執行npm install安裝套件時，如果套件本身有做更新，你可能會下載到不同次版號的套件，造成相容性問題，讓你專案出錯。<br>有了 package-lock.json檔案，當你用npm install 下載時，會下載和package-lock.json裡一模一樣的版本號。代表你和原作者會使用同樣版本的套件。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*DHfU2h1MLDxRn_RPeb9iPA.png"></p>
]]></content>
      <tags>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB (二) 新增與尋找</title>
    <url>/2022/07/16/2022-7-15-2-mongodb-find/</url>
    <content><![CDATA[<h2 id="新增單筆資料"><a href="#新增單筆資料" class="headerlink" title="新增單筆資料"></a>新增單筆資料</h2><p><img src="https://miro.medium.com/max/1400/1*gVW--Mwzkr8MGyRqEAiJqQ.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">insertOne</span>() <span class="comment">// 新增單筆資料</span></span><br></pre></td></tr></table></figure>

<p>使用insertOne()語法，在users這個collection裡面新增一筆資料(document)，資料以物件形式加入。</p>
<h2 id="新增多筆資料"><a href="#新增多筆資料" class="headerlink" title="新增多筆資料"></a>新增多筆資料</h2><p><img src="https://miro.medium.com/max/1400/1*iifEjaw0vesRmNJuc55dJA.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">insertMany</span>([])  <span class="comment">// 加入多筆資料，每筆資料為物件格式。</span></span><br></pre></td></tr></table></figure>

<h2 id="尋找資料"><a href="#尋找資料" class="headerlink" title="尋找資料"></a>尋找資料</h2><ol>
<li>尋找所有資料<br><img src="https://miro.medium.com/max/1400/1*u24PrSDc2Y_O9za1Sd5cVg.png"></li>
</ol>
<p>使用 find()，將collection 裡的所有資料(document)列出，可以看到在mongoDB裡，每一筆資料的格式可以不同，也能在物件裡再放物件格式。</p>
<ol start="2">
<li>.find({ 搜尋條件 })， 尋找指定資料</li>
</ol>
<p><img src="https://miro.medium.com/max/1400/1*1y28loJEsDtZ7HFlUP8VDw.png"></p>
<ol start="3">
<li>find({ 搜尋條件 }, { 需要欄位}): 尋找指定資料，並只回傳需要的欄位，1 代表要回傳的欄位, 0代表不要回傳的欄位</li>
</ol>
<p><img src="https://miro.medium.com/max/1400/1*rd21DIRvfdpCTdqRS-l0Dw.png" alt="只回傳 name 跟 age的欄位"></p>
<p><img src="https://miro.medium.com/max/1400/1*__9L7fjSlJVkfnh569nIdw.png" alt="回傳age以外的欄位"></p>
<h2 id="篩選資料"><a href="#篩選資料" class="headerlink" title="篩選資料"></a>篩選資料</h2><ol>
<li>限制搜尋筆數: .limit(筆數)</li>
</ol>
<p><img src="https://miro.medium.com/max/1400/1*fslx_qLREPu8Do0OA-iOSw.png"></p>
<ol start="2">
<li>資料排序: sort( {}):</li>
</ol>
<p>物件key值為要排序的屬性， value為 1(降冪) 或 -1 (升冪)</p>
<p><img src="https://miro.medium.com/max/1400/1*GDXlcgddlVyMXtV_YSXm3A.png"></p>
<ol start="3">
<li>多條件排序</li>
</ol>
<p><img src="https://miro.medium.com/max/1400/1*6l6JUe1cSsM3b1DxQi1mGQ.png"></p>
<p>sort()裡可放多屬性，會依照屬性順序做排序，如上圖會先將age做排序，若age一樣再用name做排序。</p>
<ol start="4">
<li>跳過項目 .skip(跳過數量)</li>
</ol>
<p><img src="https://miro.medium.com/max/1400/1*0G0NEDl6BejHTCqxO5DK7Q.png" alt="掠過第一筆資料"></p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB (三) 進階搜尋</title>
    <url>/2022/07/16/2022-7-17-2-mongodb-filter/</url>
    <content><![CDATA[<h2 id="進階搜尋"><a href="#進階搜尋" class="headerlink" title="進階搜尋"></a>進階搜尋</h2><p>使用進階搜尋，在find({ })裡的物件的值要再使用物件指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$eq: 搜尋相等的值</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/762/1*z5MdNdvkq8vgc0e2YSaP1g.png" alt="搜尋name等於arod的資料"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$in: 搜尋多筆資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/963/1*kBWhGNWTVIlDcXn3sms-Uw.png" alt="搜尋name為 Tom跟Lisa的資料"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$nin: 搜尋多筆不等於的資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/963/1*6V7wGbsl4V5OqWhKdQ-K9Q.png" alt="回傳name不等於 Tom跟Lisa的資料"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ne: 搜尋不等於值的所有結果</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/855/1*AHLxw1weSOF3PnMcaqI7uw.png" alt="回傳name不等於john的結果"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$gt: 回傳大於的值</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/766/1*Ew8Ue57MPOcuQxSGD3rRbg.png" alt="回傳age&gt; 13的值"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$gte: 回傳大於等於的值</span><br></pre></td></tr></table></figure>
<p><img src="https://miro.medium.com/max/756/1*Ivi-dmvotfSyyWd7EveN3g.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lt: 回傳小於的值</span><br></pre></td></tr></table></figure>
<p><img src="https://miro.medium.com/max/769/1*mnWWPxKd6nSCiOiRbieExw.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lte: 回傳小於等於的值</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/824/1*0HjXji2L2aFrS4IBvwmeKw.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$exits: 回傳欄位存在的值，true是存在，false是不存在</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/875/1*KAN637IjOrmlSVPrBlEMsg.png" alt="回傳有age欄位的值"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$not: 回傳不符合條件的資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/963/1*2k8b8OlsJcrAZrHudnosBg.png" alt="回傳 age不是小於等於40的資料"></p>
<h2 id="多重尋找"><a href="#多重尋找" class="headerlink" title="多重尋找"></a>多重尋找</h2><p><img src="https://miro.medium.com/max/963/1*VvL-74sVwh2oo8hz4JZZtA.png" alt="尋找 age &gt;=15且 &lt;=40 且 name為sara的資料"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$and: 尋找條件都符合的資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/963/1*rteWbRZYyhxGxvg8NZb5UA.png" alt="尋找 age =19且 name為sara的資料"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$or: 尋找條件之一符合的資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/963/1*AozlkrEyLbEUhTafgXYNGw.png" alt="回傳age≤40 或 name為john的資料"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$expr : 後方可放入表達式，欄位名稱要加上 $</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/963/1*-nFA_bUG5XsbTkx7GOXYTA.png" alt="回傳 $debt &gt; $balance的資料"></p>
<h2 id="深層尋找"><a href="#深層尋找" class="headerlink" title="深層尋找"></a>深層尋找</h2><p>如果資料裡還有物件，屬於巢狀結構的話，使用.的方式尋找</p>
<p><img src="https://miro.medium.com/max/963/1*bZSPltOMgAxaj5xEnnSqKw.png" alt="回傳 address裡street的值為 978 st的值"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$findOne: 回傳找到的第一筆資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/803/1*v1g2nEa4VAjP4GQQVKqd2w.png" alt="回傳age&gt;10的第一筆資料"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$countDocument: 計算資料筆數</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/963/1*52BUktA6BLIWuFDebslMkw.png" alt="回傳age≤40的筆數"></p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB (四) 更新與刪除</title>
    <url>/2022/07/17/2022-7-17-3-mongodb-update/</url>
    <content><![CDATA[<h2 id="資料更新"><a href="#資料更新" class="headerlink" title="資料更新"></a>資料更新</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updateOne(&#123;被更新的資料&#125;, &#123;更新的值&#125;)  // 更新一筆資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*ug2VR90bERK_zuhJmFfx8g.png" alt="使用$set設定新的值"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inc: 加上指定的值</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*W51QCzgqqGCkg1kerrN5zQ.png" alt="inc: 加上指定的值"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename: 更改資料的key值</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*HY-saJY9Gpey46CwgZ5oUg.png" alt="將name欄位改為lora欄位"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset: 移除指定欄位，欄位值設為&quot; &quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*-Mua6NP_A-PuJvpEEL3OaA.png" alt="移除age欄位"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push: 新增值到陣列裡</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*cmlaV3bI4wBQIEHXQLfygw.png" alt="新增swimming到hobbies陣列裡"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pull: 移除陣列裡的值</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*soqRd9QGuXDnt0fV-OWsMQ.png" alt="移除陣列裡Running的值"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updateMan: 更新多筆資料</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*sRe0B1aVt_Pv46R0II2ifA.png" alt="將所有有address的欄位取消address欄位"></p>
<h2 id="取代資料"><a href="#取代資料" class="headerlink" title="取代資料"></a>取代資料</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replaceOne: 將原本物件刪除後，取代成新的物件</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1400/1*yjbgM_WfQTt2c7DGmbVPCQ.png" alt="將原本name為lin的物件刪除後，更新成name為linda的物件"></p>
<h2 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deleteOne: 將指定物件刪除</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/1180/1*BcicLblVY6EVtI7JwnPe9g.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deleteMany: 刪除多筆資料</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB Atlas(二) cluster</title>
    <url>/2022/07/17/2022-7-17-5-mongodb-atlas-2/</url>
    <content><![CDATA[<p>建立好新的資料庫後，先設定 Database Access ，也就是誰能讀取這個資料庫。</p>
<p><img src="https://miro.medium.com/max/963/1*F2bjbKiANh6uFsQp1tpkSA.png"></p>
<p>點選 Add New Database User， 並設定user的帳號密碼</p>
<p><img src="https://miro.medium.com/max/963/1*m_dIUQS6di3FJapbiGozvg.png"></p>
<p>再來點擊左側 Network Access ，設定能讀取資料庫的ip位置</p>
<p><img src="https://miro.medium.com/max/963/1*mtkdr8aabVXwwI6IsatThw.png"></p>
<p>點選 allow access from anywhere，</p>
<p><img src="https://miro.medium.com/max/963/1*Uqnh7SBIp_tYBAUm1pYG6g.png"></p>
<p>再來點擊左側 database，再點選connect，來連接資料庫</p>
<p><img src="https://miro.medium.com/max/963/1*121AdSPsVRfepmRDFuk6uA.png"></p>
<p>點選第二個 connect your application</p>
<p><img src="https://miro.medium.com/max/963/1*ao4jvrYVDTBkrjJbSIJFCQ.png"></p>
<p>選擇 node版本 3.6以後</p>
<p><img src="https://miro.medium.com/max/963/1*_SUU-2aT2xZg0Es9UyvL8w.png"></p>
<p>複製程式碼到我們的node js專案</p>
<p><img src="https://miro.medium.com/max/963/1*57tPw1zIMwFn-utOPvOcQg.png"></p>
<p>在專案裡新增 db資料夾，並新增 connect.js</p>
<p><img src="https://miro.medium.com/max/572/1*NqGtYaYQtlb0WRYAo-FZfw.png"></p>
<p>將剛才mongodb複製的程式碼貼到js檔裡，存成字串。</p>
<p><img src="https://miro.medium.com/max/963/1*kJYiQqrSShd0_KFCJ7ydmw.png"></p>
<h2 id="建立collection"><a href="#建立collection" class="headerlink" title="建立collection"></a>建立collection</h2><p>再來建立collection，點選 browser collection</p>
<p><img src="https://miro.medium.com/max/963/1*b7CtG2I0gJMQyiMJF6HQog.png"></p>
<p>點新增資料</p>
<p><img src="https://miro.medium.com/max/963/1*jpcAAKfrTjYuQF-E53gd_Q.png"></p>
<p>輸入資料庫名稱</p>
<p><img src="https://miro.medium.com/max/648/1*qBIe4FrsTM63sUQMKusSzQ.png"></p>
<p>在database中，可以創建不同的collections ，裡面是不同的資料集。如下圖我創建了 products跟 users兩個collection</p>
<p><img src="https://miro.medium.com/max/1400/1*KaQPsHVvi9EDSRBM_l0dyQ.png"></p>
<p>點選右邊 建立 document，可以建立collection 裡的資料</p>
<p><img src="https://miro.medium.com/max/794/1*blQsTCUmepOwQsf3qOSAcw.png"></p>
<p><img src="https://miro.medium.com/max/1400/1*_KsCSl0FYeKEMLiZkaAHTA.png"></p>
]]></content>
      <tags>
        <tag>MongoDB Atlas</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB Atlas(一) 申請帳號</title>
    <url>/2022/07/17/2022-7-17-4-mongodb-altas-1/</url>
    <content><![CDATA[<p>MongoDB Atlas是MongoDB公司的雲端資料庫服務，使用流程如下:</p>
<h2 id="申請MongoDB-Atlas帳號"><a href="#申請MongoDB-Atlas帳號" class="headerlink" title="申請MongoDB Atlas帳號:"></a>申請MongoDB Atlas帳號:</h2><p>首先來到<a href="https://www.mongodb.com/docs/atlas/getting-started/">教學文件</a>，選擇 part 1 建立 Atlas 帳號</p>
<p><img src="https://miro.medium.com/max/963/1*Hjhk1iYTMWb_GCy_K4NBXw.png"></p>
<p>點選 Navigate to MongoDB Atlas <a href="https://account.mongodb.com/account/login">login page</a>，建立帳號，可選擇以 google帳號登入</p>
<p><img src="https://miro.medium.com/max/963/1*Sgx4vYxwmNQKpvPLWpgncw.png"></p>
<h2 id="登入後，選擇-免費方案"><a href="#登入後，選擇-免費方案" class="headerlink" title="登入後，選擇 免費方案"></a>登入後，選擇 免費方案</h2><p><img src="https://miro.medium.com/max/963/1*zlpW3hRL4mjLRzqOmpwDZg.png"></p>
<h2 id="建立新的-cluster，可以使用預設選項"><a href="#建立新的-cluster，可以使用預設選項" class="headerlink" title="建立新的 cluster，可以使用預設選項"></a>建立新的 cluster，可以使用預設選項</h2><p><img src="https://miro.medium.com/max/963/1*BdPWvYS1aBgAffyGUDi4hQ.png"></p>
]]></content>
      <tags>
        <tag>MongoDB Atlas</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongoose (1) 安裝並整合到專案</title>
    <url>/2022/07/17/2022-7-17-6-mongoose-1/</url>
    <content><![CDATA[<h2 id="Mongoose-是什麼"><a href="#Mongoose-是什麼" class="headerlink" title="Mongoose 是什麼?"></a>Mongoose 是什麼?</h2><p>Mongoose 是 MongoDB 的 ODM（Object Data Modeling） 套件，可以讓我們更方便處理 CRUD。透過 mongoose 的使用，我們可以更像在操作 relational database。</p>
<h2 id="安裝-mongoose"><a href="#安裝-mongoose" class="headerlink" title="安裝 mongoose"></a>安裝 mongoose</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save mongoose</span><br></pre></td></tr></table></figure>

<p>安裝好後到Express專案內新增 db 資料夾，資料夾裡新增 connect.js，這隻js裡會放連線到資料庫用的程式。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071701.png?alt=media&token=8e3d4509-43ec-400a-9683-075f4e06ada7"></p>
<p>在 connect.js 裡載入mongoose，將 mongoose方法包在 connectDB函式裡並匯出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">connectDB</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> mongoose.<span class="title function_">connect</span>(url, &#123;</span><br><span class="line">    <span class="attr">useNewUrlParser</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">useCreateIndex</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">useFindAndModify</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = connectDB</span><br></pre></td></tr></table></figure>

<p>在app.js裡 載入 connectDB方法，為了讓 我們的專案在資料庫連接成功後再啟動，使用 await語法等待 connectDB()成功後，再去做app.listen()。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>).<span class="title function_">config</span>();</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> connectDB = <span class="built_in">require</span>(<span class="string">&#x27;./db/connect&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = process.<span class="property">env</span>.<span class="property">PORT</span> || <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">start</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">connectDB</span>(process.<span class="property">env</span>.<span class="property">MONGO_URL</span>);</span><br><span class="line">    app.<span class="title function_">listen</span>(port, <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`server is listening port <span class="subst">$&#123;port&#125;</span>`</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>();</span><br></pre></td></tr></table></figure>

<p>上面連線的port我們會存在 .env 檔裡，再用 <code>process.env.變數</code>的方式載入，這麼做是為了將機密資訊都放在 .env檔裡管理， .env檔並不會上傳到github上，因此相對而言是安全的。</p>
]]></content>
      <tags>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(11) dotenv 套件</title>
    <url>/2022/07/17/2022-7-17-7-dotenv/</url>
    <content><![CDATA[<h2 id="什麼是dotenv"><a href="#什麼是dotenv" class="headerlink" title="什麼是dotenv"></a>什麼是dotenv</h2><p>一般來說不會把資料庫連線帳號、密碼等相關訊息寫在程式碼裡面，通常寫在一個檔案裡面。而在 node.js 的專案裡，我們可以將機密資訊儲存在 .env 檔中來管理。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install dotenv --save  // 安裝套件</span><br></pre></td></tr></table></figure>

<h2 id="載入套件"><a href="#載入套件" class="headerlink" title="載入套件"></a>載入套件</h2><p>在express的專案中載入套件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>).<span class="title function_">config</span>();</span><br></pre></td></tr></table></figure>

<h2 id="新增-env-檔"><a href="#新增-env-檔" class="headerlink" title="新增 .env 檔"></a>新增 .env 檔</h2><p>在專案根目錄新增 .env 檔</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022071702.png?alt=media&token=7a875b5c-01fa-4eb2-9b41-795559f47e02"></p>
<h2 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h2><p>在 .env檔裡可以儲存資訊，用<code>變數=值</code>的方式儲存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MYDATA=123456</span><br></pre></td></tr></table></figure>

<h2 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h2><p>.env檔的資料建好後，可以來讀取讀，語法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process.env.變數名稱</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongoose (2) 建立model與schema</title>
    <url>/2022/07/17/2022-7-17-8-mongoose-model/</url>
    <content><![CDATA[<h2 id="Mongoose-觀念與名詞"><a href="#Mongoose-觀念與名詞" class="headerlink" title="Mongoose 觀念與名詞"></a>Mongoose 觀念與名詞</h2><p>Mongoose 提供了 schema-based 的解決方案讓我們直接操作資料，在透過 Mongoose 操作資料庫時，有幾個名詞要先有概念:</p>
<ul>
<li>Schema: 存資料庫模型的檔案</li>
<li>Model: 由 Schema 當參數產生的 instance 可以用來操作資料庫</li>
<li>collection: 在 MongoDB 中的表</li>
</ul>
<h2 id="Mongoose-Schema-設計"><a href="#Mongoose-Schema-設計" class="headerlink" title="Mongoose Schema 設計"></a>Mongoose Schema 設計</h2><p>要使用 Mongoose 操作的第一步就是要從定義 Schema 開始，定義完成後 Schema 會自動對應到 MongoDB 中的一個 collection，另外因為不像傳統資料庫那樣有 join 的概念，所以拿資料的時候可以依照我們的使用情境去設計，像是以撈取為主的話就可以透過雙向參照的設計去加速，詳細可以參考MongoDB Schema 設計指南。</p>
<h2 id="建立-Schema"><a href="#建立-Schema" class="headerlink" title="建立 Schema"></a>建立 Schema</h2><p><img src="https://miro.medium.com/max/842/1*kzEelgX6y-K3JF6dTMFElA.png"></p>
<p><img src="https://miro.medium.com/max/1400/1*DkN-K-S-ONv16m1V4wFJAQ.png"></p>
<p>在model資料夾裡，建立js檔，並利用 monggose.Schema({})，來建立所有document的結構。只有在 Schema 裡建立的屬性如 name，才會傳入mogodb資料庫。</p>
<p>建立好 Schema 結構， 在將schema建立成一個model實體 可以用來操作資料庫(crud)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;Product&#x27;</span>, productSchema);</span><br></pre></td></tr></table></figure>

<h2 id="schema-拆分"><a href="#schema-拆分" class="headerlink" title="schema 拆分"></a>schema 拆分</h2><p><img src="https://miro.medium.com/max/1376/1*MTktN8cHSR_vVoz5N_yWhA.png"></p>
<p>當要定義的物件過於複雜時，可以另外拆分一個schema來定義，如上圖address的值是定義在 addressSchema裡。</p>
<h2 id="schema-驗證"><a href="#schema-驗證" class="headerlink" title="schema 驗證"></a>schema 驗證</h2><p><img src="https://miro.medium.com/max/1400/1*Tzl9Vg6A_Z4nPDE3KumAHw.png"></p>
<p>schema 裡資料格式的也可做驗證，可用方法:</p>
<ul>
<li>type: String | Number | Boolean | Date  &#x2F;&#x2F; 指定屬性的型別 </li>
<li>required: true | false  &#x2F;&#x2F;是否必填</li>
<li>trim: true | false  &#x2F;&#x2F;是否去頭尾空白</li>
<li>maxlength: 最多字數。</li>
<li>min: 最小值。</li>
<li>max: 最大值。</li>
<li>default: 預設值。</li>
<li>lowercase: true | false  &#x2F;&#x2F;是否要小寫</li>
<li>uppercase: true | false  &#x2F;&#x2F;是否要大寫</li>
<li>immutable:  true | false  &#x2F;&#x2F;是否可修改</li>
</ul>
<p>補充日期預設方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">createAt</span>: &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="title class_">Date</span>,</span><br><span class="line">  <span class="attr">default</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>(), <span class="comment">// 每次建立物件時，會給新的日期。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>validate: 自訂驗證函式(validator)，並可回傳message</p>
<p><img src="https://miro.medium.com/max/1400/1*A_uOjCJwU-B83LJsIYYnpw.png"></p>
<h2 id="schema-加上方法"><a href="#schema-加上方法" class="headerlink" title="schema 加上方法"></a>schema 加上方法</h2><p>我們可以在 schema加上方法，讓每個new出來的document使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">person.<span class="property">methods</span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi My name is <span class="subst">$&#123;Kyle&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法建立在schema可以在每個實體使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="keyword">await</span> person.<span class="title function_">find</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Kyle&#x27;</span> &#125;); </span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// Hi My name is Kyle</span></span><br></pre></td></tr></table></figure>
<h2 id="model操作資料"><a href="#model操作資料" class="headerlink" title="model操作資料"></a>model操作資料</h2><p><img src="https://miro.medium.com/max/1362/1*we3LBZ7EKHPeN3mNiXkhXA.png"></p>
<p>在我們controllers裡的js檔裡，可以將剛才export的model引入。</p>
<p><img src="https://miro.medium.com/max/1164/1*RwDqw3zkTCV5XXHAdgOzLw.png"></p>
<p>上面是post方法對應的函式，可以使用 Task.create()方法，將使用者傳來的資料，建立成一筆 document。詳細的Model操作方法下一章節介紹。</p>
]]></content>
      <tags>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongoose (3) model方法介紹</title>
    <url>/2022/07/17/2022-7-17-9-mongoose-model-2/</url>
    <content><![CDATA[<h2 id="搜尋資料"><a href="#搜尋資料" class="headerlink" title="搜尋資料"></a>搜尋資料</h2><h3 id="搜尋全部資料"><a href="#搜尋全部資料" class="headerlink" title="搜尋全部資料"></a>搜尋全部資料</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="built_in">require</span>(<span class="string">&#x27;../models/person&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">await</span> <span class="title class_">Person</span>.<span class="title function_">find</span>(&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 find 方法傳入空物件，會回傳所有資料。因為find會回傳 .then() ，所以可以用 await 來接收結果。</p>
<h3 id="搜尋特定資料"><a href="#搜尋特定資料" class="headerlink" title="搜尋特定資料"></a>搜尋特定資料</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.</span><br><span class="line">  <span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="attr">occupation</span>: <span class="regexp">/host/</span>,</span><br><span class="line">    <span class="string">&#x27;name.last&#x27;</span>: <span class="string">&#x27;Ghost&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: &#123; <span class="attr">$gt</span>: <span class="number">17</span>, <span class="attr">$lt</span>: <span class="number">66</span> &#125;,  <span class="comment">// 年齡 &gt;17 &amp;&amp; &lt;66</span></span><br><span class="line">    <span class="attr">likes</span>: &#123; <span class="attr">$in</span>: [<span class="string">&#x27;vaporizing&#x27;</span>, <span class="string">&#x27;talking&#x27;</span>] &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>如果要對值進行篩選，可以在後方加入篩選語法，語法和 <a href="https://tim8076.github.io/2022/07/16/2022-7-17-2-mongodb-filter/">mongodb</a> 是一樣的。</p>
<h3 id="限制資料比數"><a href="#限制資料比數" class="headerlink" title="限制資料比數"></a>限制資料比數</h3><p>想限制資料筆數，可以加上 .limit</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="title function_">find</span>(&#123;&#125;).<span class="title function_">limit</span>(<span class="number">10</span>) <span class="comment">// 回傳前10筆資料</span></span><br></pre></td></tr></table></figure>

<h3 id="資料排序"><a href="#資料排序" class="headerlink" title="資料排序"></a>資料排序</h3><p>要對特定值做排序，用 sort方法，。加上 - 代表降冪排序，反之則正向排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="title function_">find</span>(&#123;&#125;).<span class="title function_">sort</span>(<span class="string">&#x27;name -occupation&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="回傳特定的key值"><a href="#回傳特定的key值" class="headerlink" title="回傳特定的key值"></a>回傳特定的key值</h3><p>如果只想回傳特定的key值，用 select()。 加上 - 代表降冪排序，反之則正向排序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="title function_">find</span>(&#123;&#125;).<span class="title function_">select</span>(<span class="string">&#x27;name -gender&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h2 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="built_in">require</span>(<span class="string">&#x27;../models/person&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Kyle&#x27;</span>, <span class="attr">age</span>: <span class="number">16</span> &#125;);</span><br><span class="line"><span class="keyword">await</span> person.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure>
<p>用mongoose新增一筆資料很簡單，假設有一個 Person 的model，只要用 new Person({})帶入新增的值即可建立資料，再用.save()將資料存進資料庫，因為.save()是 async function ，所以記得加上 await。</p>
<h2 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="built_in">require</span>(<span class="string">&#x27;../models/person&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Kyle&#x27;</span>, <span class="attr">age</span>: <span class="number">16</span> &#125;);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Sally&#x27;</span>;</span><br><span class="line"><span class="keyword">await</span> person.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure>

<p>修改資料可以直接將物件的值賦予新的值，再用 .save() 存入資料庫即可。如上我們將 Kyle 改為 Sally。</p>
<h2 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="built_in">require</span>(<span class="string">&#x27;../models/person&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Person</span>.<span class="title function_">deleteOne</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Kyle&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>deleteOne 會刪除符合條件的第一筆資料。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="built_in">require</span>(<span class="string">&#x27;../models/person&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Person</span>.<span class="title function_">deleteMany</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Kyle&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>deleteMany 刪除所有符合條件的資料。</p>
]]></content>
      <tags>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongoose (4) middleware介紹</title>
    <url>/2022/07/20/2022-7-20-1-mongoose-middleware/</url>
    <content><![CDATA[<h2 id="使用-middleware"><a href="#使用-middleware" class="headerlink" title="使用 middleware"></a>使用 middleware</h2><p>在mongoose裡，我們也可以使用middleware函式，middlware作用在schema層級，分為  pre and post 兩種，以下介紹使用方法。</p>
<h2 id="使用-pre-函示"><a href="#使用-pre-函示" class="headerlink" title="使用 pre 函示"></a>使用 pre 函示</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="title class_">String</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">UserSchema</span>.<span class="title function_">pre</span>(<span class="string">&#x27;save&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.<span class="title function_">genSalt</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">password</span> = <span class="keyword">await</span> bcrypt.<span class="title function_">hash</span>(<span class="variable language_">this</span>.<span class="property">password</span>, salt);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>document middleware可以被綁定不同的函式如下:</p>
<ul>
<li>validate</li>
<li>save</li>
<li>remove</li>
<li>updateOne</li>
<li>deleteOne</li>
</ul>
<p>如上例 ， 當UserSchema被儲存 <code>.save()</code> 時，會先觸發middleware將password加密。</p>
<h2 id="範例-連帶移除資料"><a href="#範例-連帶移除資料" class="headerlink" title="範例 連帶移除資料"></a>範例 連帶移除資料</h2><p>假設我們在資料庫想刪除一筆 product 資料，並連帶刪除所有該 product 的review資料，可以先用 .remove() 刪除該product</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deleteProduct</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> productId = req.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">  <span class="keyword">const</span> product = <span class="keyword">await</span> <span class="title class_">Product</span>.<span class="title function_">findOne</span>(&#123; <span class="attr">_id</span>: productId &#125;);</span><br><span class="line">  <span class="keyword">await</span> product.<span class="title function_">remove</span>();</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="title class_">StatusCodes</span>.<span class="property">OK</span>).<span class="title function_">json</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;success product removed&#x27;</span> &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 product的 schema 上用pre hook來刪除連帶的 reviews資料</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ProductSchema</span>.<span class="title function_">pre</span>(<span class="string">&#x27;remove&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">next</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">model</span>(<span class="string">&#x27;Review&#x27;</span>).<span class="title function_">deleteMany</span>(&#123; <span class="attr">product</span>: <span class="variable language_">this</span>.<span class="property">_id</span> &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>await product.remove() 會觸發 schema上的 pre hook，先用 this.model(‘Review’)連到 reivew model，在將所有 包含product id的review刪除。</p>
]]></content>
      <tags>
        <tag>Express</tag>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT 介紹</title>
    <url>/2022/07/18/2022-7-18-1-jwt/</url>
    <content><![CDATA[<h2 id="JWT-運作原理"><a href="#JWT-運作原理" class="headerlink" title="JWT 運作原理"></a>JWT 運作原理</h2><p><img src="https://cdn-images-1.medium.com/max/1100/1*_B02lJ2aSxKt4bCh7Q1-ZA.png"></p>
<p>當使用者傳送post request 到伺服器時，伺服器會產生Json Web Token用來加密使用者傳來的資料，並使用 secrest key來加密。<br>加密完後就會將JWT回傳給瀏覽器，瀏覽器可以選擇各種儲存token的方式例如cookie。<br>當使用者再次發出request請求時，會在header附帶上JWT token，伺服器收到token後會使用 同樣secrest key來進行解密，確認token的資料是否一樣。確認token沒問題後，就可從token中取得user的資料，例如帳密，再回傳給前端。</p>
<h2 id="和session的差異"><a href="#和session的差異" class="headerlink" title="和session的差異"></a>和session的差異</h2><p>session運作的原理和jwt類似，但主要差別是，session會儲存user資料在伺服器，伺服器利用session id來尋找user資料。<br>jwt則將使用者資料存在token裡，token則會被保存在前端，伺服器不用儲存任何資料。也就是說，可以使用同樣的token在不同的伺服器上，不像session可能遇到不同伺服器有不同session而無法登入的情況。</p>
<h2 id="JWT-加密過程"><a href="#JWT-加密過程" class="headerlink" title="JWT 加密過程"></a>JWT 加密過程</h2><p><img src="https://cdn-images-1.medium.com/max/1100/1*HptXxES6PVfkrYYNNAGERw.png"></p>
<p>左欄是加密後的JWT TOKEN，右欄則是解密後的token，解密後的token分為三部分:</p>
<ul>
<li>HEADER:  包含用來加密、解密的演算法。</li>
<li>PAYLOAD: 儲存在token裡的資料。</li>
<li>VERIFY SIGNATURE: 用來驗證token是否被使用者更改。</li>
</ul>
<p>使用base64URL來加密或解密HEADER跟PAYLOAD，並使用secret Key來加解密，也就是左欄紅色跟紫色的密碼。<br>實際流程: 當伺服器收到jwt token後，會將左欄紅色跟紫色的密碼，用指定的演算法(上圖是HS256)來hash，並確認hash後的值是否等於最後一段藍色的密碼。</p>
<h2 id="實戰加密流程"><a href="#實戰加密流程" class="headerlink" title="實戰加密流程"></a>實戰加密流程</h2><h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><p>在node.js專案中，先下載套件 jsonwebtoken</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save jsonwebtoken </span><br></pre></td></tr></table></figure>

<p>在 controller 裡引入jwt</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="後端加密"><a href="#後端加密" class="headerlink" title="後端加密"></a>後端加密</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">login</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = req.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDate</span>();</span><br><span class="line">  <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(&#123; id, username &#125;, process.<span class="property">env</span>.<span class="property">JWT_SECRET</span>, &#123; <span class="attr">expiresIn</span>: <span class="string">&#x27;30d&#x27;</span> &#125;)</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;user created&#x27;</span>,</span><br><span class="line">    token,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>jwt.sign()</code> 來加密，加密完後將token回傳給前端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jwt.sign(&#123; payload &#125;, 金鑰, &#123; expiresIn : 過期時間&#125; )</span><br></pre></td></tr></table></figure>

<ul>
<li>第一個參數為 payload: 使用者和相關的資訊都可以放置其中(ex: id、name)。</li>
<li>第二個是金鑰字串，通常會是複雜的字串存在.env檔裡</li>
<li>第三個可傳入 token 過期時間</li>
</ul>
<p>不要將隱私資訊存放在 Payload 當中， Payload 和 Header 被轉換成 Base64 編碼後，能夠被輕易的轉換回來<br>因此不應該把如用戶密碼等重要資料存取在 Payload 當中</p>
<h3 id="前端接收token"><a href="#前端接收token" class="headerlink" title="前端接收token"></a>前端接收token</h3><p>前端發出網路請求後成功後(例如登入成功)，會收到後端回傳的token，前端可以先存入 localStorage</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/v1/login&#x27;</span>, &#123; username, password &#125;)</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, data.<span class="property">token</span>)</span><br></pre></td></tr></table></figure>

<p>當再次發出的請求是需要驗證時，需要傳token給後端驗證。在HEADER中使用Authorization並帶入存取的Token</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/v1/dashboard&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="title class_">Authorization</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="後端接收token"><a href="#後端接收token" class="headerlink" title="後端接收token"></a>後端接收token</h3><p>當後端收到前端帶有token的請求後，可以從 <code>req.headers.authorization</code> 裡收到token的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  authorization: &#x27;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTgsInVzZXJuYW1lIjoicGV0ZXIiLCJpYXQiOjE2NTgxMjk2OTQsImV4cCI6MTY2MDcyMTY5NH0.4RNbP5jIx9GU1-makuVaxhU3g-cSbXhRJWynitjhu3Y&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用split方法取得 Bearer 後面的token字串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> authHeader = req.<span class="property">headers</span>.<span class="property">authorization</span>;</span><br><span class="line"><span class="keyword">if</span> (!authHeader || !authHeader.<span class="title function_">startsWith</span>(<span class="string">&#x27;Bearer &#x27;</span>)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomAPIError</span>(<span class="string">&#x27;No token provided&#x27;</span>, <span class="number">400</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> token = authHeader.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>取得 token字串後，可以用 <code>jwt.verify(token, 金鑰)</code> 來解析</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> decoded = jwt.<span class="title function_">verify</span>(token, process.<span class="property">env</span>.<span class="property">JWT_SECRET</span>);</span><br></pre></td></tr></table></figure>

<p>當token解析符合金鑰字串時，就會將當初加密的物件(payload)解析出來:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tim&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(10) async-errors 套件</title>
    <url>/2022/07/16/2022-7-17-async-error/</url>
    <content><![CDATA[<h2 id="async-errors-套件"><a href="#async-errors-套件" class="headerlink" title="async-errors 套件"></a>async-errors 套件</h2><p>以往在使用async await 語法時，時常會用try catch處理非同步事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在express專案裡可以載入 async-errors 套件來取代try catch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install express-async-errors --save</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先在 app.js 裡載入套件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;express-async-errors&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>然後當有錯誤發生時，在router函式裡可以直接丟出Error錯誤</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getAllProductsStatic</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;testing async errors&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">json</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;Product testing route&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在app.js的最後則可用一個處理錯誤的middleware來承接錯誤</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (err, req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  <span class="keyword">return</span> res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">json</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;Something went wrong, please try again&#x27;</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(12) 錯誤處理範例</title>
    <url>/2022/07/20/2022-7-20-2-error-handle/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在node.js裡遇到錯誤時我們可能會直接丟出錯誤</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;testing async errors&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>在這章節會介紹如何統整不同錯誤的api在一個資料夾，方便管理。</p>
<h2 id="新增errors資料夾"><a href="#新增errors資料夾" class="headerlink" title="新增errors資料夾"></a>新增errors資料夾</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- errrors</span><br><span class="line">  - index.js</span><br><span class="line">  - custom-api.js</span><br><span class="line">  - bad-request.js</span><br><span class="line">  - not-found.js</span><br><span class="line">- middleware</span><br><span class="line">  - error-handler</span><br></pre></td></tr></table></figure>

<p>首先在根目錄建立errors資料夾，底下會有處裡不同錯誤的js檔，以下分別說明</p>
<h2 id="custom-api"><a href="#custom-api" class="headerlink" title="custom-api"></a>custom-api</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomAPIError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">CustomAPIError</span></span><br></pre></td></tr></table></figure>

<p>建立 custom-api.js 檔，裡面我們會 extend 一個 CustomAPIError 的 class ，再將 CustomAPIError 匯出。</p>
<h2 id="建立不同錯誤的js"><a href="#建立不同錯誤的js" class="headerlink" title="建立不同錯誤的js"></a>建立不同錯誤的js</h2><p>當我們建立好 CustomAPIError 後，可以新增不同錯誤的js檔，以下以 Badrequest 錯誤為例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">StatusCodes</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-status-codes&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CustomAPIError</span> = <span class="built_in">require</span>(<span class="string">&#x27;./custom-api&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadRequestError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CustomAPIError</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">statusCode</span> = <span class="title class_">StatusCodes</span>.<span class="property">BAD_REQUEST</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">BadRequestError</span>;</span><br></pre></td></tr></table></figure>

<p>Badrequest 一樣會extend CustomAPIError ，statusCode的部分則會用’http-status-codes’這個套件帶入錯誤代碼。</p>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><p>當不同錯誤的js檔建立好了，可以再新增 index.js統一匯出，這樣之後要使用不同錯誤方法時，可以統一由index這邊匯入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CustomAPIError</span> = <span class="built_in">require</span>(<span class="string">&#x27;./custom-api&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UnauthenticatedError</span> = <span class="built_in">require</span>(<span class="string">&#x27;./unauthenticated&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">NotFoundError</span> = <span class="built_in">require</span>(<span class="string">&#x27;./not-found&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BadRequestError</span> = <span class="built_in">require</span>(<span class="string">&#x27;./bad-request&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="title class_">CustomAPIError</span>,</span><br><span class="line">  <span class="title class_">UnauthenticatedError</span>,</span><br><span class="line">  <span class="title class_">NotFoundError</span>,</span><br><span class="line">  <span class="title class_">BadRequestError</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>要使用錯誤方法時，可以先將要用的方法從index.js匯入使用，再將錯誤拋出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BadRequestError</span>, <span class="title class_">UnauthenticatedError</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../errors&#x27;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestError</span>(<span class="string">&#x27;Please provide email and password&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="error-middleware"><a href="#error-middleware" class="headerlink" title="error middleware"></a>error middleware</h2><p>當錯誤拋出後，會進到 error-handler 的 middleware 處理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CustomAPIError</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../errors&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">StatusCodes</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-status-codes&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">errorHandlerMiddleware</span> = (<span class="params">err, req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> customError = &#123;</span><br><span class="line">    <span class="attr">statusCode</span>: err.<span class="property">statusCode</span> || <span class="title class_">StatusCodes</span>.<span class="property">INTERNAL_SERVER_ERROR</span>,<span class="string">`</span></span><br><span class="line"><span class="string">    message: err.message || &#x27;Something went wrong try again later&#x27;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return res.status(customError.statusCode).json(&#123; msg: customError.message &#125;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">module.exports = errorHandlerMiddleware</span></span><br></pre></td></tr></table></figure>

<p>errorHandlerMiddleware 函式接收的 err 參數如果是我們自行丟出的會有 statusCode 和 message，我們就回傳customError的資訊。若不是則回傳預設的  StatusCodes.INTERNAL_SERVER_ERROR 。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Express實戰系列(1) 製作註冊登入功能</title>
    <url>/2022/07/20/2022-7-20-3-express-login/</url>
    <content><![CDATA[<h2 id="環境簡介"><a href="#環境簡介" class="headerlink" title="環境簡介"></a>環境簡介</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- controllers  </span><br><span class="line">  - auth.js</span><br><span class="line">- model</span><br><span class="line">  - User.js</span><br><span class="line">- route    </span><br><span class="line">  - auth.js</span><br><span class="line">- middleware</span><br><span class="line">  - authentication</span><br></pre></td></tr></table></figure>

<p>這次要製作註冊登入功能，route 和 controllers 資料夾理會有 auth的 路由(route) 和 函式(controller)，另外有建立User的model。本次使用 express搭配 mongoDB製作。</p>
<h2 id="建立User的schema"><a href="#建立User的schema" class="headerlink" title="建立User的schema"></a>建立User的schema</h2><p>首先在 model裡的 User.js建立user的 schema，也就是每筆使用者的資料格式，包括用戶姓名、email、password等等。會用到mongoose提供的驗證方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">UserSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: [<span class="literal">true</span>, <span class="string">&#x27;Please provide name&#x27;</span>],</span><br><span class="line">    <span class="attr">maxlength</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">minlength</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">email</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: [<span class="literal">true</span>, <span class="string">&#x27;Please provide email&#x27;</span>],</span><br><span class="line">    <span class="attr">match</span>: [</span><br><span class="line">      <span class="regexp">/^(([^&lt;&gt;()[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/</span>,</span><br><span class="line">      <span class="string">&#x27;Please provide a valid email&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">unique</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: [<span class="literal">true</span>, <span class="string">&#x27;Please provide password&#x27;</span>],</span><br><span class="line">    <span class="attr">minlength</span>: <span class="number">6</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在user的schema裡可以新增加密的方法，使用 bcrypt套件來對password加密，因為希望password加密後再存入資料庫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserSchema</span>.<span class="title function_">pre</span>(<span class="string">&#x27;save&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.<span class="title function_">genSalt</span>(<span class="number">10</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">password</span> = <span class="keyword">await</span> bcrypt.<span class="title function_">hash</span>(<span class="variable language_">this</span>.<span class="property">password</span>, salt)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="註冊路由"><a href="#註冊路由" class="headerlink" title="註冊路由"></a>註冊路由</h2><p>註冊使用者的 controller 函式如下: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = <span class="built_in">require</span>(<span class="string">&#x27;../models/User&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">StatusCodes</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-status-codes&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BadRequestError</span>, <span class="title class_">UnauthenticatedError</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../errors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者註冊</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">register</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">create</span>(&#123; ...req.<span class="property">body</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> token = user.<span class="title function_">createJWT</span>()</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="title class_">StatusCodes</span>.<span class="property">CREATED</span>).<span class="title function_">json</span>(&#123; <span class="attr">user</span>: &#123; <span class="attr">name</span>: user.<span class="property">name</span> &#125;, token &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>製作註冊功能時，使用者在前端會傳入 name 跟 password 的資料，資料會以物件方式存在 req.body裡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;王曉明&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當路由收到資料後，用 <code>.create()</code>建立新的使用者，此時如果使用少傳了name或password，會觸發 mongoose 的驗證機制，直接拋出錯誤。</p>
<p>建立使用者後，用寫在<a href="https://tim8076.github.io/2022/07/17/2022-7-17-8-mongoose-model/?highlight=schema#schema-%E5%8A%A0%E4%B8%8A%E6%96%B9%E6%B3%95">User的schema上的方法</a>來產生 jwt的 token，最後這個token會回傳給前端做下次登入驗證用，詳細<a href="https://tim8076.github.io/2022/07/18/2022-7-18-1-jwt/?highlight=jwt#%E5%AF%A6%E6%88%B0%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B">jwt用法看這裡</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserSchema</span>.<span class="property">methods</span>.<span class="property">createJWT</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> jwt.<span class="title function_">sign</span>(</span><br><span class="line">    &#123; <span class="attr">userId</span>: <span class="variable language_">this</span>.<span class="property">_id</span>, <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">name</span> &#125;,</span><br><span class="line">    process.<span class="property">env</span>.<span class="property">JWT_SECRET</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">expiresIn</span>: process.<span class="property">env</span>.<span class="property">JWT_LIFETIME</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="登入路由"><a href="#登入路由" class="headerlink" title="登入路由"></a>登入路由</h2><p>當使用者成功註冊後，可以進行登入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">login</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; email, password &#125; = req.<span class="property">body</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!email || !password) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestError</span>(<span class="string">&#x27;Please provide email and password&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123; email &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnauthenticatedError</span>(<span class="string">&#x27;Invalid Credentials&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isPasswordCorrect = <span class="keyword">await</span> user.<span class="title function_">comparePassword</span>(password)</span><br><span class="line">  <span class="keyword">if</span> (!isPasswordCorrect) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnauthenticatedError</span>(<span class="string">&#x27;Invalid Credentials&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// compare password</span></span><br><span class="line">  <span class="keyword">const</span> token = user.<span class="title function_">createJWT</span>()</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="title class_">StatusCodes</span>.<span class="property">OK</span>).<span class="title function_">json</span>(&#123; <span class="attr">user</span>: &#123; <span class="attr">name</span>: user.<span class="property">name</span> &#125;, token &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先從req.body裡可以取得前端傳來的 email和password資料</p>
<ol>
<li><p>先檢查 email 和 password 是否存在，不存在的話直接丟出錯誤。</p>
</li>
<li><p>確認有帳密資料後，用 email資料取得資料庫裡對應的user資料，如果找不到user則回傳錯誤。</p>
</li>
<li><p>再來比對使用者輸入的密碼是否一樣，使用 bcrypt套件裡的compare功能，比對的函式一樣放在UserSchema的methods裡。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">UserSchema</span>.<span class="property">methods</span>.<span class="property">comparePassword</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">canditatePassword</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isMatch = <span class="keyword">await</span> bcrypt.<span class="title function_">compare</span>(canditatePassword, <span class="variable language_">this</span>.<span class="property">password</span>)</span><br><span class="line">  <span class="keyword">return</span> isMatch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>確認密碼一樣後，就可以新增 jwt token 並回傳端，登入成功。</p>
<h2 id="新增驗證的middleware"><a href="#新增驗證的middleware" class="headerlink" title="新增驗證的middleware"></a>新增驗證的middleware</h2><p>使用者註冊和登入後，前端會獲得token，作為之後驗證使用。可以在middleware資料夾內新增 autentication的js檔。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">auth</span> = <span class="keyword">async</span> (<span class="params">req, res, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> authHeader = req.<span class="property">headers</span>.<span class="property">authorization</span>;</span><br><span class="line">  <span class="keyword">if</span> (!authHeader || !authHeader.<span class="title function_">startsWith</span>(<span class="string">&#x27;Bearer&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnauthenticatedError</span>(<span class="string">&#x27;Authentication invalid&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> token = authHeader.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> payload = jwt.<span class="title function_">verify</span>(token, process.<span class="property">env</span>.<span class="property">JWT_SECRET</span>);</span><br><span class="line">    req.<span class="property">user</span> = &#123; <span class="attr">userId</span>: payload.<span class="property">userId</span>, <span class="attr">name</span>: payload.<span class="property">name</span> &#125;;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnauthenticatedError</span>(<span class="string">&#x27;Authentication invalid&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在驗證邏輯中，前端會將token放在headers.authorization裡，所以先判斷 req 裡有沒有 authorization 的資料，沒有則回報錯誤。<br>若有則將token字串取出，之後用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jwt.verify(token, token金鑰)</span><br></pre></td></tr></table></figure>

<p>將token資料解析回當初加密前的物件格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">  <span class="attr">userId</span>: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取得物件後，就將資訊存在 req.user裡，方便之後再路由裡取得user資訊。</p>
]]></content>
      <tags>
        <tag>Express實戰系列</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie 介紹(一) 概念篇</title>
    <url>/2022/07/24/2022-7-24-1-cookie-1/</url>
    <content><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/1100/0*xElr-lBELjhvCKM1.png"></p>
<p><img src="https://cdn-images-1.medium.com/max/1100/1*7JB8X8Z3wYWCcc5ox_GhEQ.png"></p>
<p><img src="https://cdn-images-1.medium.com/max/1100/1*ZF-rXeZmto6Qfq7kubbw2g.png"></p>
<p><img src="https://cdn-images-1.medium.com/max/1100/1*t53-Lx0pAOoZrRPBRXGXKQ.png"></p>
]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(13) 安全處理套件</title>
    <url>/2022/07/22/2022-7-22-1-express-safe-plugins/</url>
    <content><![CDATA[<p>這篇介紹幾個常用的 安全性套件如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install helmet --save   // helmet藉由設定多個http-header來保護app</span><br><span class="line">npm install cors --save     // cors允許跨域的網路請求</span><br><span class="line">npm install xss-clean --save  // 防止xss攻擊</span><br><span class="line">npm install express-rate-limit  // 防止太頻繁的請求</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn-images-1.medium.com/max/1320/1*iiglV8mBgWLo9fmYK2f2kQ.png" alt="載入套件"></p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*PXV7BHiBXv1zxakGrrVfSg.png" alt="使用套件"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode 常用套件</title>
    <url>/2022/07/22/2022-7-22-2-vscodes-plugins/</url>
    <content><![CDATA[<ol>
<li>Monokai Dark Soda</li>
</ol>
<p>將樣式改為 sublime 配色</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*NO_R722LcJMiVFOtN7u2bQ.png"></p>
<ol start="2">
<li>Live Server</li>
</ol>
<p>幫助我們建立本地端serve，來開啟html檔案。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*UutF0FyzyEhBea3QEy_nKg.png"></p>
<ol start="3">
<li>AutoFileName</li>
</ol>
<p>自動補齊文件路徑</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*RWm3j8aBqGyN5N_M8xldiQ.png"></p>
<ol start="4">
<li>Copy filename</li>
</ol>
<p>右鍵點選檔案，可以直接複製檔名</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*1puNqb7bDaubwhfzxzaQhQ.png"></p>
<ol start="5">
<li>git graph</li>
</ol>
<p>快速瀏覽 git commit 與 分支</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/35f08c9edb0403027a52b8941abf732b.png"></p>
<ol start="6">
<li>Material Icon Theme</li>
</ol>
<p>提供好看的檔案 icon 圖示</p>
<p><img src="https://raw.githubusercontent.com/PKief/vscode-material-icon-theme/main/logo.png"></p>
]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie 介紹(二) Client 端設計</title>
    <url>/2022/07/24/2022-7-24-2-cookie-2/</url>
    <content><![CDATA[<h2 id="在瀏覽器讀取與寫入cookie"><a href="#在瀏覽器讀取與寫入cookie" class="headerlink" title="在瀏覽器讀取與寫入cookie"></a>在瀏覽器讀取與寫入cookie</h2><h3 id="讀取所有cookie"><a href="#讀取所有cookie" class="headerlink" title="讀取所有cookie"></a>讀取所有cookie</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>    <span class="comment">// 讀取所有cookie</span></span><br></pre></td></tr></table></figure>

<p>document.cookie會讀取瀏覽器裡所有cookie並組成同個字串如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;test1=Hello; SameSite=None;  //讀取結果</span><br></pre></td></tr></table></figure>

<h3 id="讀取單一cookie"><a href="#讀取單一cookie" class="headerlink" title="讀取單一cookie"></a>讀取單一cookie</h3><p>如果要取出特定cookie的值，我們可以套用function，只要帶入cookie的name，就會返回cookie的值。以下提供一個範例:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="string">`; <span class="subst">$&#123;<span class="variable language_">document</span>.cookie&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">const</span> parts = value.<span class="title function_">split</span>(<span class="string">`; <span class="subst">$&#123;name&#125;</span>=`</span>);</span><br><span class="line">  <span class="keyword">if</span> (parts.<span class="property">length</span> === <span class="number">2</span>) <span class="keyword">return</span> parts.<span class="title function_">pop</span>().<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>).<span class="title function_">shift</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寫入cookie"><a href="#寫入cookie" class="headerlink" title="寫入cookie"></a>寫入cookie</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;myName=bob&#x27;</span>   <span class="comment">// 寫入cookie</span></span><br></pre></td></tr></table></figure>

<h2 id="設定cookie-失效時間"><a href="#設定cookie-失效時間" class="headerlink" title="設定cookie 失效時間"></a>設定cookie 失效時間</h2><p><img src="https://cdn-images-1.medium.com/max/1100/1*ih5ywCh6YHGSf4ndllwkuA.png"></p>
]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie 介紹(三) Node.js Server 設計</title>
    <url>/2022/07/24/2022-7-24-3-cookie-3/</url>
    <content><![CDATA[<h2 id="載入cookieParser"><a href="#載入cookieParser" class="headerlink" title="載入cookieParser"></a>載入cookieParser</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save cookie-parser</span><br></pre></td></tr></table></figure>

<p>先下載cookie-parser這個套件，才能讀取cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(cookieParser);</span><br></pre></td></tr></table></figure>

<h2 id="讀取cookie"><a href="#讀取cookie" class="headerlink" title="讀取cookie"></a>讀取cookie</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.cookie  //讀取cookie</span><br></pre></td></tr></table></figure>

<p>在後端的路由裡，可以用 req.cookies 讀取整包cookie物件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">cookie</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn-images-1.medium.com/max/1100/1*MGJQh6eKcOY12UDRUylx5A.png" alt="讀取結果"></p>
<h2 id="傳送-cookie-到前端"><a href="#傳送-cookie-到前端" class="headerlink" title="傳送 cookie 到前端"></a>傳送 cookie 到前端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.cookie(name, value [, options])</span><br></pre></td></tr></table></figure>

<p>name: 設定cookie的名字<br>value: 設定其值，可能是字串或是轉成JSON格式的物件。<br>options: 選項參數是一個物件，所以，其屬性放在{}裡，以逗號分隔。</p>
<p>可用options:</p>
<ul>
<li>expires (日期) cookie的到期日，超過此日期，即失效。</li>
<li>httpOnly: (布林) 標記此cookie只能從web server　訪問，以避免不正確的進入來取得竄改。</li>
<li>maxAge (數字) 設定此cookie的生存時間(毫秒為單位)，比方60000(10分鐘後到期，必須重新訪問)</li>
<li>path (字串) 適用此cookie的路徑，預設： “&#x2F;”.</li>
<li>secure (布林) 設定此cookie是否只在https使用。</li>
<li>signed (布林) 此cookie是否要設簽章。(如果是true，必須使用cookie-parser設定簽章 )</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">cookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;marry&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">httpOnly</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">10000</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Express實戰系列(2) 使用cookie傳送JWT token</title>
    <url>/2022/07/24/2022-7-24-4-express-cookie-example/</url>
    <content><![CDATA[<h2 id="註冊功能"><a href="#註冊功能" class="headerlink" title="註冊功能"></a>註冊功能</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">attatchCookieToResponse</span> = (<span class="params">&#123; res, user &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="title function_">createJWT</span>(&#123; <span class="attr">payload</span>: user &#125;);</span><br><span class="line">  <span class="keyword">const</span> oneDay = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>; <span class="comment">//one day in miliseconds</span></span><br><span class="line">  res.<span class="title function_">cookie</span>(<span class="string">&#x27;token&#x27;</span>, token, &#123;</span><br><span class="line">    <span class="attr">httpOnly</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">expires</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() + oneDay),</span><br><span class="line">    <span class="attr">secure</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    <span class="attr">signed</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用res.cookie 回傳 jwt 產生的token，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">register</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; email, name, password &#125; = req.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(&#123; email, password, name, role &#125;);</span><br><span class="line">  <span class="keyword">await</span> user.<span class="title function_">save</span>();</span><br><span class="line">  <span class="keyword">const</span> tokenUser = &#123; </span><br><span class="line">    <span class="attr">name</span>: user.<span class="property">name</span>, </span><br><span class="line">    <span class="attr">userId</span>: user.<span class="property">_id</span>, </span><br><span class="line">    <span class="attr">role</span>: user.<span class="property">role</span> </span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">attatchCookieToResponse</span>(&#123; res, <span class="attr">user</span>: tokenUser &#125;);</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="title class_">StatusCodes</span>.<span class="property">CREATED</span>).<span class="title function_">json</span>(&#123; <span class="attr">user</span>: tokenUser &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Express實戰系列</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Express框架(14) bcrypt 套件</title>
    <url>/2022/07/26/2022-7-26-1-express-bcrypt/</url>
    <content><![CDATA[<h2 id="什麼是-bcrypt"><a href="#什麼是-bcrypt" class="headerlink" title="什麼是 bcrypt"></a>什麼是 bcrypt</h2><p>在儲存密碼到後端資料庫時，要避免直接將密碼以字串方式存入，以防資料庫被害時密碼洩漏。所以應該再存入密碼前將密碼加密，也就是本文會介紹的 bcrypt套件 來加密。</p>
<p>bcrypt 能夠將一個字串做雜湊加密，其中有個參數叫 saltRounds 是在密碼學中的加鹽(salt)，加鹽的意思是在要加密的字串中加特定的字符，打亂原始的字符串，使其生成的散列結果產生變化，其參數越高加鹽次數多越安全相對的加密時間就越長。</p>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install bcrypt --save</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>saltRounds: 整數型態，數值越高越安全。</li>
<li>myPassword: 要加密的字串。</li>
<li>testPassword: 測試驗證密碼的變數。</li>
<li>myHash: myPassword加密後結果(給驗證用)</li>
</ul>
<p>以下為promises 非同步的加密與解密方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密</span></span><br><span class="line">bcrypt.<span class="title function_">hash</span>(myPassword, saltRounds).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">hash</span>) &#123;</span><br><span class="line">  <span class="comment">// Store hash in your password DB.</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(hash);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驗證密碼</span></span><br><span class="line">bcrypt.<span class="title function_">compare</span>(myPassword, myHash).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br><span class="line">bcrypt.<span class="title function_">compare</span>(testPassword, myHash).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也支援 async&#x2F;await 的寫法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">checkUser</span>(<span class="params">username, password</span>) &#123;</span><br><span class="line">    <span class="comment">//... fetch user from a db etc.</span></span><br><span class="line">    <span class="keyword">const</span> match = <span class="keyword">await</span> bcrypt.<span class="title function_">compare</span>(password, user.<span class="property">passwordHash</span>);</span><br><span class="line">    <span class="keyword">if</span>(match) &#123;</span><br><span class="line">        <span class="comment">//login</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 的使用</title>
    <url>/2022/07/28/2022-7-28-1-promise/</url>
    <content><![CDATA[<h2 id="過去處理非同步方法"><a href="#過去處理非同步方法" class="headerlink" title="過去處理非同步方法"></a>過去處理非同步方法</h2><p>在以前，我們會用 callback function 去控制非同步事件發生的順序，如下圖，利用將 logB 帶入logA函式中，確保 logA 執行完後才執行 logB;</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*u2dx3XZLuYAXJ23Fybz73Q.png"></p>
<h2 id="使用promise"><a href="#使用promise" class="headerlink" title="使用promise"></a>使用promise</h2><p><img src="https://cdn-images-1.medium.com/max/1320/1*dUI30vm_J711TulAMNkIbQ.png"></p>
<p>而現在，我們有promise可以用，promise 主要用來解決非同步的問題，因為非同步事件我們無法確定什麼時候完成，所以會有一個 pending 未確認的狀態。</p>
<p>等待未確認狀態完成後，才會進入 settled 已確認狀態，settled 已確認狀態，可分為兩部分:</p>
<ol>
<li>fulfilled : 已實現狀態，代表非同步事件完成。</li>
</ol>
<p>在完成狀態裡，promise會透過 resolve參數回傳一個結果，並透過then來 做接收。</p>
<ol start="2">
<li>rejected : 已拒絕狀態，代表非同步事件失敗。</li>
</ol>
<p>在失敗狀態裡，promise會透過 reject參數回傳一個結果，並透過catch來做接收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseFn</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;失敗&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">promiseFn</span>(<span class="number">0</span>)</span><br><span class="line">  .<span class="title function_">then</span>( <span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;程式碼結束&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在上面範例中，利用一個 function 內new出 promise的實體，並用 resolve 和 reject 參數 分別帶出成功和失敗的結果。<br>在運行promiseFn 藉由 帶入的參數是真值，如 1  或假值 如 0，來決定 是用 then接收成功結果，或是用 catch 接收失敗結果。</p>
<h2 id="Promise-鏈接"><a href="#Promise-鏈接" class="headerlink" title="Promise 鏈接"></a>Promise 鏈接</h2><p><img src="https://cdn-images-1.medium.com/max/1320/1*yvKI941jMsOCyIjW1R0pug.png"></p>
<p>在上圖中，在第一個 then 接收成功資訊，並再 return 一個promisefn。此時因為帶入的是假值 0 ，直接跳到 .catch 進行失敗資訊接收。在catch裡，也可以再 做一次promiseFn(4) 此時帶入的是真值，故由底下的then來接收成功結果。</p>
<h2 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h2><p><img src="https://cdn-images-1.medium.com/max/1320/1*t3Q8bc1-xu3sl2B0NLd2Jw.png"></p>
<p>在使用 promise .all 時，可以在陣列裡一次帶入多個promise請求，並用.then  一次回傳成功的結果，要注意回傳的格式也是陣列，所以可以用res[0]的方式去取值。<br>另外只要有一個promise請求失敗，就會直接跳入.catch 接收失敗訊息，並不會執行其餘成功的結果。</p>
<h2 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race"></a>promise.race</h2><p>promise .race 和 promise.all 一樣，可以同時用陣列的方式傳入多個promise請求，但 promise .race 只會回傳第一個完成的結果，若成功則進入.then，若是失敗則進入 .catch。<br>下圖範例中， promiseFn(0,300)會先執行完，然後因為是 0 是假值，直接進入.catch接收失敗結果。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*86cuLYtVeu-Aez8QI54cZg.png"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Async Await</title>
    <url>/2022/07/29/2022-7-29-1-async-await/</url>
    <content><![CDATA[<h2 id="promise的作法"><a href="#promise的作法" class="headerlink" title="promise的作法"></a>promise的作法</h2><p><img src="https://miro.medium.com/max/1292/1*kbLtHl6rlpk9mQZMh6vjyg.png"></p>
<p><img src="https://miro.medium.com/max/1192/1*_qmqlT1cYHhKxdPw2oHpVA.png"></p>
<p>傳統的promise寫法，我們會用 .then()去接收成功的結果，.catch()接收失敗的結果。但不斷用.then去接收結果，程式上的可讀性較差，所以可以改用async await的寫法來改寫。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><p><img src="https://miro.medium.com/max/1392/1*7xEFqbxd6W5rOHC5wmnXjQ.png"></p>
<p>async 的使用方法很簡單，只要在定義 function 時，前面加個 async 就可以了。而 await 會接收promise執行完的結果，等 Promise 執行完再執行下一行，後面的任務會等前面的任務完成後才繼續下去。</p>
<p>如果想接收錯誤的結果，可以用try catch寫法，將所有可能出錯的程式放在try裡，當有程式回傳錯誤時，會立即停止，並執行catch裡的程式</p>
<p><img src="https://miro.medium.com/max/1356/1*3P-AW4xqVs-gGroh5rU36g.png"></p>
<p>當 async function 的內容全都結束後，會返回一個 promise，這表示後方可以使用.then語法來做連接，基本的程式長相就像下面這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">  .....       <span class="comment">// 等 b() 完成後才會執行</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">c</span>();</span><br><span class="line">  .....       <span class="comment">// 等 c() 完成後才會執行</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;);</span><br><span class="line">  .....       <span class="comment">// 上方的 promise 完成後才會執行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"><span class="title function_">a</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  .....       <span class="comment">// 等 a() 完成後接著執行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/tim-chou/pen/ZEyBzpb?editors=1012">範例參考:</a></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Mongoose (5) populate介紹</title>
    <url>/2022/07/28/2022-7-28-2-mongoose-populate/</url>
    <content><![CDATA[<h2 id="model-關聯屬性建立"><a href="#model-關聯屬性建立" class="headerlink" title="model 關聯屬性建立"></a>model 關聯屬性建立</h2><p>在 mongoose 的 modle 屬性裡，我們可以互相連結不同 model 的資料</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ProductSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: mongoose.<span class="property">Types</span>.<span class="property">ObjectId</span>,</span><br><span class="line">      <span class="attr">ref</span>: <span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>例如上面的 product 的 schema 我連結了 user 的資料。</p>
<h2 id="使用-populate-擴展資料"><a href="#使用-populate-擴展資料" class="headerlink" title="使用 populate 擴展資料"></a>使用 populate 擴展資料</h2><p>在沒有 populate前，當我們get product資料時，只會得到 user的 id。</p>
<p>但我們可以使用 populate 來擴展 user 的完整資料</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getAllProducts</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> products = <span class="keyword">await</span> <span class="title class_">Review</span>.<span class="title function_">find</span>(&#123;&#125;)</span><br><span class="line">  .<span class="title function_">populate</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">    <span class="attr">select</span>: <span class="string">&#x27;name age gender&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  res.<span class="title function_">status</span>(<span class="title class_">StatusCodes</span>.<span class="property">OK</span>).<span class="title function_">json</span>(&#123; products &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>populate可用屬性</p>
<ul>
<li>path: 要擴展的屬性名稱</li>
<li>select: 需要擴展的key</li>
</ul>
]]></content>
      <tags>
        <tag>Express</tag>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Class</title>
    <url>/2022/07/30/2022-7-30-1-js-class/</url>
    <content><![CDATA[<h2 id="函式建構式"><a href="#函式建構式" class="headerlink" title="函式建構式"></a>函式建構式</h2><p>javascript沒有原生的class，是透過「原型」來繼承方法。透過函式建構式的方式，透過 new 關鍵字來產生新的物件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lucy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lucy&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>但由於這種寫法與其他物件導向的程式語言差異太大，所以從ES6開始導入了Class語法。</p>
<h2 id="Class語法糖"><a href="#Class語法糖" class="headerlink" title="Class語法糖"></a>Class語法糖</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello this is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> lucy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lucy&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(lucy.<span class="title function_">greeting</span>()) <span class="comment">// Hello this is lucy</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先在class關鍵字後是class的名稱，內部的 constructor函式與原本的 建構函式 function Person(name) {} 是一樣的，greeting方法則直接寫入class裡。</p>
<h2 id="Class與-constructor-function的差異"><a href="#Class與-constructor-function的差異" class="headerlink" title="Class與 constructor function的差異"></a>Class與 constructor function的差異</h2><ol>
<li>函式可以被提升，而class不會，會出現「TDZ」暫時性死區</li>
<li>直接呼叫class名稱，而不是透過 new關鍵字來呼叫，會出現錯誤。</li>
<li>class的區塊內所有程式碼，預設會進入嚴格模式。</li>
</ol>
<h2 id="class-的靜態方法"><a href="#class-的靜態方法" class="headerlink" title="class 的靜態方法"></a>class 的靜態方法</h2><p>class 裡面可以宣告靜態方法 (static method)，其效果等同於直接定義一個方法在class的屬性上，不用new出新物件就可調用方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Article</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">compare</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">date</span> &lt; b.<span class="property">date</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">articles.<span class="title function_">sort</span>(<span class="title class_">Article</span>.<span class="property">compare</span>);</span><br></pre></td></tr></table></figure>

<h2 id="extends-繼承類別"><a href="#extends-繼承類別" class="headerlink" title="extends 繼承類別"></a>extends 繼承類別</h2><p>class可以用extends語法繼承。例如，想要 Rabbit class繼承自 Animal class。非常簡單，只要使用 class Rabbit extends Animal 語法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Run...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>();</span><br><span class="line">rabbit.<span class="title function_">run</span>(); <span class="comment">// From `Animal`</span></span><br></pre></td></tr></table></figure>

<h2 id="super-覆寫方法"><a href="#super-覆寫方法" class="headerlink" title="super 覆寫方法"></a>super 覆寫方法</h2><p>就像其他語言一樣，繼承的類別可以覆寫母類別的方法，但是通常我們不一定想要整個覆蓋掉母類別的方法，而是會根據既有的母類別的方法去延伸功能。想要延伸既有的方法，可以用 super 關鍵字，呼叫母類別的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Animal run!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(); <span class="comment">// Animal run!</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Rabbit jump!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="super-覆寫-constructor"><a href="#super-覆寫-constructor" class="headerlink" title="super 覆寫 constructor"></a>super 覆寫 constructor</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, earLength</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">earLength</span> = earLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="keyword">new</span> <span class="title class_">Rabbit</span>(<span class="string">&#x27;John&#x27;</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>利用 super 關鍵字，在constructor內，呼叫母類別的 constructor。因為母類別已經有 this.name &#x3D; name; 的邏輯了，不需要在子類別重寫一次 this.name &#x3D; name ，直接呼叫 super(name); 就可以了。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax解說系列(5) CORS</title>
    <url>/2022/07/05/2022-7-5-1-js-cors/</url>
    <content><![CDATA[<h2 id="Cross-Origin-Resource-Sharing"><a href="#Cross-Origin-Resource-Sharing" class="headerlink" title="Cross-Origin Resource Sharing"></a>Cross-Origin Resource Sharing</h2><p>當我們使用 XMLHttpRequest 或 fecth等方式向伺服器發送請求時，都必須遵守都遵守同源政策（same-origin policy），只能請求與應用程式相同網域的 HTTP 資源。</p>
<p>跨來源資源共用（CORS），則是一種使用額外 HTTP 標頭令目前瀏覽網站的使用者代理取得存取其他來源（網域）伺服器特定資源權限的機制。</p>
<p>當對方開啟 CORS，就能存取跨網域的資源。</p>
<p>使用 api 前可以到，<a href="https://test-cors.org/">test-cors.org</a> 網站測試 api</p>
<p>結果 200 代表可串接<br>結果 0 代表不能跨網域串接</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongoose (6) virtual</title>
    <url>/2022/07/29/2022-7-29-3-mongoose-virtual/</url>
    <content><![CDATA[<h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><p>我們知道可以用 populate 來擴展實際在model裡有聯結的屬性，如下我們在 product裡連結了 user</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ProductSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: mongoose.<span class="property">Types</span>.<span class="property">ObjectId</span>,</span><br><span class="line">      <span class="attr">ref</span>: <span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>但當 model裡沒有連結屬性有想擴展該屬性時，可以用 virtual。</p>
<h2 id="開啟virtual"><a href="#開啟virtual" class="headerlink" title="開啟virtual"></a>開啟virtual</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ProductSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;, </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">toJSON</span>: &#123; <span class="attr">virtuals</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="attr">toObject</span>: &#123; <span class="attr">virtuals</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>首先在 schema的第二個參數裡，將 toJSON 、toObject 的 virtuals 設為 true，讓schema能接收 vritual。</p>
<h2 id="設定-virtual"><a href="#設定-virtual" class="headerlink" title="設定 virtual"></a>設定 virtual</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ProductSchema</span>.<span class="title function_">virtual</span>(<span class="string">&#x27;reviews&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">ref</span>: <span class="string">&#x27;Review&#x27;</span>,</span><br><span class="line">  <span class="attr">localField</span>: <span class="string">&#x27;_id&#x27;</span>,</span><br><span class="line">  <span class="attr">foreignField</span>: <span class="string">&#x27;product&#x27;</span>,</span><br><span class="line">  <span class="attr">justOne</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">match</span>: &#123; <span class="attr">rating</span>: <span class="number">5</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 productSchema 上先設定 virtual 連結到 reviews</p>
<ul>
<li>ref: 要連結的 model 名稱</li>
<li>localField: schema要連結的屬性</li>
<li>foreignField: 連結model裡的屬性</li>
<li>justone: 是否只取回一筆資料</li>
<li>match: 只取回符合條件的資料</li>
</ul>
<p>以上範例中，在productSchema上新增一個 virtual的屬性命名為 reviews，將ref設定為 ‘Review’ 來取得Review model的資料。<br>在 localField 中設定 ‘_id’ 代表 product 的id， foreignField 設為 product 則會將 Review model 裡所有有該 product id的reviews回傳。</p>
<h2 id="pupulate"><a href="#pupulate" class="headerlink" title="pupulate"></a>pupulate</h2><p>當以上都設定好後，在controller裡 populate 該 virtual 屬性即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSingleProduct</span> = <span class="keyword">async</span> (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> productId = req.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">  <span class="keyword">const</span> product = <span class="keyword">await</span> <span class="title class_">Product</span>.<span class="title function_">findOne</span>(&#123; <span class="attr">_id</span>: productId &#125;).<span class="title function_">populate</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;reviews&#x27;</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Express</tag>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 箭頭函式</title>
    <url>/2022/07/29/2022-7-29-2-arrow-function/</url>
    <content><![CDATA[<h2 id="箭頭函式"><a href="#箭頭函式" class="headerlink" title="箭頭函式"></a>箭頭函式</h2><p>箭頭函式(Arrow Functions)是ES6後提供的新的函式撰寫方法，箭頭函式省略 function ，並在小括號後 加上 &#x3D;&gt;<br>寫法如下: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">([param] [, param]) =&gt; &#123;</span><br><span class="line">   statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="縮寫"><a href="#縮寫" class="headerlink" title="縮寫"></a>縮寫</h2><p><img src="https://miro.medium.com/max/1186/1*ESxQlngtFWX4n1s2aenzaA.png"></p>
<p>另外如果程式碼只有一行 ，可將{ }省略，並且不用寫 return，因為 箭頭函式 預設就有return；</p>
<p><img src="https://miro.medium.com/max/1170/1*9IF91hfHL3P8GkqFRKEEqg.png"></p>
<p>如果參數只有一個，小括號 ( )也可省略</p>
<p><img src="https://miro.medium.com/max/1084/1*kDJRvdiX4f8BFUVfA7F7hg.png"></p>
<p>若沒有參數，小括號 () 不可省略</p>
<h2 id="沒有-this"><a href="#沒有-this" class="headerlink" title="沒有 this"></a>沒有 this</h2><p>和傳統函式不同，箭頭函式沒有自己的this，所以它的this會沿用外層的this</p>
<p><img src="https://miro.medium.com/max/1106/1*JQNWRCFVt4ScYCqNoFSHlw.png"></p>
<h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><h3 id="無法回傳-物件實字"><a href="#無法回傳-物件實字" class="headerlink" title="無法回傳 物件實字"></a>無法回傳 物件實字</h3><p>因為 物件的 { } 會被當作 箭頭函式結構的一部分，導致無法回傳物件。</p>
<p><img src="https://miro.medium.com/max/778/1*mynKPfZszhSThbM3JLrYoQ.png"></p>
<p>解決方法是在 物件外 加上 ( ) 包住</p>
<p><img src="https://miro.medium.com/max/862/1*jnDAY_EmMmMf9LFwbGRnrQ.png"></p>
<h3 id="搭配判斷式時，不能直接接箭頭函式"><a href="#搭配判斷式時，不能直接接箭頭函式" class="headerlink" title="搭配判斷式時，不能直接接箭頭函式"></a>搭配判斷式時，不能直接接箭頭函式</h3><p><img src="https://miro.medium.com/max/730/1*OR1_s2JDhdFL2y60Da27tw.png"></p>
<p>解決方法依樣在外面加上 ( )</p>
<p><img src="https://miro.medium.com/max/804/1*E_mYA5m_ncwWoXN--eIi8w.png"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 解構賦值</title>
    <url>/2022/07/05/2022-7-5-2-js-Destructuring/</url>
    <content><![CDATA[<h2 id="傳統陣列賦值方式"><a href="#傳統陣列賦值方式" class="headerlink" title="傳統陣列賦值方式"></a>傳統陣列賦值方式</h2><p><img src="https://miro.medium.com/max/1348/1*WRcYmXNDmWXhrmOBVYS34Q.png" alt="傳統傳統賦值"></p>
<p>以往作法我們會將 family 裡的值一一取出，在分別賦予到新的變數上。</p>
<h2 id="陣列解構賦值"><a href="#陣列解構賦值" class="headerlink" title="陣列解構賦值"></a>陣列解構賦值</h2><p><img src="https://miro.medium.com/max/1330/1*KVVs3jLuIIJLivh1ni2xnA.png" alt="陣列解構"></p>
<p>將右方 family 的陣列資料，鏡射到左方的陣列中，如此左方陣列裡的變數就可以被賦予family陣列裡的值。</p>
<p>若鏡射時左右數量不同，則剩下的值不會做解構賦值，如下圖，老媽、老爸就不會作賦值。</p>
<p><img src="https://miro.medium.com/max/1318/1*DWgYoQQAPpEH_tUejL1ujg.png" alt="陣列解構"></p>
<p>若左方陣列有空白，則空白會被跳過，不會被賦值。</p>
<p><img src="https://miro.medium.com/max/1314/1*rTlQeB9E5esDJJQKr5vJBg.png" alt="空白跳過"></p>
<h2 id="字串解構"><a href="#字串解構" class="headerlink" title="字串解構"></a>字串解構</h2><p>字串也可以用類似陣列的手法，進行解構賦值。</p>
<p><img src="https://miro.medium.com/max/1100/1*YIo9Qm5uJ2rHAFPOd3o3dw.png" alt="字串解構"></p>
<h2 id="物件解構"><a href="#物件解構" class="headerlink" title="物件解構"></a>物件解構</h2><p><img src="https://miro.medium.com/max/932/1*W0aj9nt9dyVof6E0vQiQeg.png" alt="物件解構"></p>
<p>我們可以 利用一個 { } ，取出右方GinyuTeam物件裡Ginyu屬性的值，</p>
<p>賦予到 Ginyu這個變數上。</p>
<p><img src="https://miro.medium.com/max/952/1*jzBRrM81reRf7TMxA6rfQw.png" alt="物件解構"></p>
<p>也可以賦予 Ginyu 一個新的變數名稱 kobe，此時 kobe就被賦予Ginyu的值。</p>
<h2 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h2><p><img src="https://miro.medium.com/max/1184/1*xJW3YCVIfO6gx1zapA8sOg.png" alt="預設值"></p>
<p>我們也可以使用預設值的方式，當左方變數沒有被右方賦值時，就使用預設值</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p><img src="https://miro.medium.com/max/982/1*ryzueSCVtqdlplZdq8u-pg.png" alt="物件解構"></p>
<p>將 GinyuTeam 用…拆出裡面的值，再放到新的 { }中，然後再將這個物件，賦予到 newTeam，此時 newTeam和GinyuTeam是兩個不同物件。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Debounce &amp; Throttle</title>
    <url>/2022/08/01/2022-8-1-js-debounce/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當出現頻繁發出 api 請求的情況時，我們可以用 debounce 或 throttle來控制發出請求的頻率，來提升使用者體驗。</p>
<h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022080101.png?alt=media&token=60283d21-62fb-48cd-aed8-48b0fd2bc642"></p>
<p>假設今天我們在搜尋欄位輸入文字，底下會自動跳出相關結果，這代表每次使用者打字時都會發出一次api請求，去取得搜尋結果。若要降低請求的頻率，我們可以使用 debounce 讓請求經過指定的等待時間後再發出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> updateDebounceText = <span class="title function_">debounce</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">  debounceText.<span class="property">textContent</span> = text;</span><br><span class="line">&#125;, <span class="number">250</span>)</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  defaultText.<span class="property">innerHTML</span> = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">  <span class="title function_">updateDebounceText</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">cb, delay = <span class="number">1000</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>(...args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 input 搜尋欄位偵聽 input 事件，也就是使用者每次打字時 會去觸發 debounce 函式。在 debounce 函式中我們會傳入一個 callback function 並回傳一個新的函式。 在這個新的函式中，會設定 setTimeout 來指定等待的時間，等時間到後再去執行 cb 函式。</p>
<p>要注意的是，每次執行函式時會先 clearTimeout，清除 setTimeout的計時器，再重新設定新的計時器。也就是說當使用者不斷打字觸發函式時，會不斷清除計時器，讓計時器重新計時，此時 cb 函式 都不會被執行，直到使用者停止打字並且計時器到時時，才會去執行函式。</p>
<p>以上就能做到等使用者打完字，在一次發出請求的目的了。</p>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><p>Throttle 是另一種減緩事件觸發方法，它與Debounce的差異是，為使用者觸發相同事件時提供間隔，控制特定時間內事件觸發的次數。適合用在像 卷軸事件 和 滑鼠事件 這些會頻繁觸發的事件中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">updateThrottleText</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">cb, delay = <span class="number">1000</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> shouldWait = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> watingArgs;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">timeoutFunc</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (watingArgs == <span class="literal">null</span>) &#123;</span><br><span class="line">      shouldWait = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>(...watingArgs);</span><br><span class="line">      watingArgs = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(timeoutFunc , delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldWait) &#123;</span><br><span class="line">      watingArgs = args;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">cb</span>(...args);</span><br><span class="line">    shouldWait = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(timeoutFunc , delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 debounce 一樣會傳入 cb 函式到 throttle 中，並設定 shouldWait 預設為 false，讓事件第一次會被執行，並在被執行後將shouldWait 設為true，讓事件在等待的時間間隔內不會被執行，直到 setTimeout 的時間到後，會再將 shouldWait 設為 false讓事件執行。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>debounce</tag>
      </tags>
  </entry>
  <entry>
    <title>(3) JS實作系列 貪吃蛇</title>
    <url>/2022/07/05/2022-7-5-3-js-snake/</url>
    <content><![CDATA[<p><img src="https://firebasestorage.googleapis.com/v0/b/project-fb4ac.appspot.com/o/2022070501.png?alt=media&token=6741a203-d871-44fe-bb24-89915fb088d7" alt="snake-game"></p>
<p><a href="https://tim8076.github.io/JS-underground-snake-game/">Demo 連結</a><br><a href="https://github.com/tim8076/JS-underground-snake-game">程式碼</a></p>
<p>這次要來實作貪吃蛇小遊戲，因為程式較多，會將JS檔案拆分再用export 、import來匯入和匯出，方便做程式碼管理。</p>
<h2 id="繪製網格"><a href="#繪製網格" class="headerlink" title="繪製網格"></a>繪製網格</h2><p>在遊戲畫面中的格子，我們可以用 <a href="https://tim8076.github.io/2022/06/28/2022-6-28-1-css-grid/?highlight=grid">grid</a> 來繪製。用 grid 製作的好處是方便我們在js中取得每個格子的座標將蛇繪製到網格上，網格數量則使用css變數來帶入。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.game-board</span> &#123;</span><br><span class="line">  <span class="attr">--col-num</span>: <span class="number">28</span>;</span><br><span class="line">  <span class="attr">--row-num</span>: <span class="number">16</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">640px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--color-primary);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">var</span>(--color-primary);</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="built_in">var</span>(--col-num), <span class="number">1</span>fr);</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="built_in">var</span>(--row-num), <span class="number">1</span>fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="建立動畫-loop-函式"><a href="#建立動畫-loop-函式" class="headerlink" title="建立動畫 loop 函式"></a>建立動畫 loop 函式</h2><p>要讓貪吃蛇不停地在畫面上移動，我們需要一個可以每秒更新的函式，以往可以用 setInterval來達成。但 setInterval 可能會有時間誤差的問題，所以我們改用 <a href="https://tim8076.github.io/2022/06/27/2022-6-24-1-js-requestAnimation/">requestAnimationFrame</a> 來製作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastRenderTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> speed = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">currentTime</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> currentPage = <span class="title function_">getCurrentPage</span>();</span><br><span class="line">  <span class="keyword">const</span> requestId = <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">  <span class="keyword">const</span> secondSinceLastRender = (currentTime - lastRenderTime) / <span class="number">1000</span>; <span class="comment">// 將milisecond 轉成 second</span></span><br><span class="line">  <span class="keyword">if</span> (secondSinceLastRender &lt; <span class="number">1</span> / speed) <span class="keyword">return</span>;</span><br><span class="line">  lastRenderTime = currentTime;</span><br><span class="line">  <span class="title function_">update</span>();</span><br><span class="line">  <span class="title function_">draw</span>();</span><br><span class="line">  <span class="keyword">if</span> (currentPage !== <span class="string">&#x27;game-page&#x27;</span>) <span class="title function_">cancelAnimationFrame</span>(requestId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(animate);</span><br></pre></td></tr></table></figure>
<p>requestAnimationFrame 會在我們設定的時間到後自動執行函式，讓貪吃蛇能持續移動。</p>
<h2 id="繪製貪吃蛇"><a href="#繪製貪吃蛇" class="headerlink" title="繪製貪吃蛇"></a>繪製貪吃蛇</h2><p>貪吃蛇的身體是由不同格子組成，我們可以用物件帶入x 跟y的值，代表該節身體的位置。之後我們在操作蛇的移動和增加身體時，都是在操作這個陣列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> snakeBody = [</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">14</span>, <span class="attr">y</span>: <span class="number">6</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">14</span>, <span class="attr">y</span>: <span class="number">7</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">x</span>: <span class="number">14</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>移動身體的部分，概念是將每節身體的位置，設定成上一節身體的位置，這樣每次繪製影格時，蛇就會移動。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = snakeBody.<span class="property">length</span> - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">     snakeBody[i + <span class="number">1</span>] = &#123; ...snakeBody[i] &#125;;  <span class="comment">// 設定最後一個的元素變成倒數第二的元素</span></span><br><span class="line">   &#125;</span><br><span class="line">   snakeBody[<span class="number">0</span>].<span class="property">x</span> += direction.<span class="property">x</span>;</span><br><span class="line">   snakeBody[<span class="number">0</span>].<span class="property">y</span> += direction.<span class="property">y</span>;</span><br></pre></td></tr></table></figure>

<p>那有了蛇的 x y 座標後，剩下的就是在html中將對應的座標選起來，並加上對應的class。<br>如蛇的頭部 index 是 0，就加上head的class。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">drawSnake</span>(<span class="params">gameBoard, boardSet</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> gridItems = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.grid-item&#x27;</span>);</span><br><span class="line">  gridItems.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">className</span> = <span class="string">&#x27;grid-item&#x27;</span>);</span><br><span class="line">  snakeBody.<span class="title function_">forEach</span>(<span class="function">(<span class="params">body, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> gridItem = <span class="title function_">getGridItemByXY</span>(&#123; gameBoard, boardSet, <span class="attr">postion</span>: body &#125;);</span><br><span class="line">    gridItem.<span class="property">className</span> = <span class="string">&#x27;grid-item&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) gridItem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;head&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">1</span>) gridItem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;gray-100&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">2</span>) gridItem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;gray-200&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">3</span>) gridItem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;gray-300&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">4</span>) gridItem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;gray-400&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">4</span>) gridItem.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是製作的貪吃蛇遊戲的方法囉。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>JS實作系列</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 陣列方法</title>
    <url>/2022/08/02/2022-8-2-1-js-array/</url>
    <content><![CDATA[<p><img src="https://miro.medium.com/max/1400/1*itebCZpmLKF37J-JvBZzlA.png"></p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>針對原陣列跑迴圈，方法會將陣列內的每個元素，皆傳入並執行給定的函式一次。不會產生新的陣列。依照陣列的長度，決定執行的次數。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">array1.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(element));</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output: &quot;a&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;b&quot;</span></span><br><span class="line"><span class="comment">// expected output: &quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="filter-陣列篩選"><a href="#filter-陣列篩選" class="headerlink" title="filter 陣列篩選"></a>filter 陣列篩選</h2><p>針對初始陣列跑迴圈，filter() 會一一將陣列中的每個元素帶入函式測試，如果函式的回傳值為 true，則會將當前的元素回傳至新陣列中，若為 false 則不保留。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;spray&#x27;</span>, <span class="string">&#x27;limit&#x27;</span>, <span class="string">&#x27;elite&#x27;</span>, <span class="string">&#x27;exuberant&#x27;</span>, <span class="string">&#x27;destruction&#x27;</span>, <span class="string">&#x27;present&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = words.<span class="title function_">filter</span>(<span class="function"><span class="params">word</span> =&gt;</span> word.<span class="property">length</span> &gt; <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="map-陣列轉換"><a href="#map-陣列轉換" class="headerlink" title="map 陣列轉換"></a>map 陣列轉換</h2><p>map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。適合用來做陣列的轉換</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass a function to map</span></span><br><span class="line"><span class="keyword">const</span> map1 = array1.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map1);</span><br><span class="line"><span class="comment">// expected output: Array [2, 8, 18, 32]</span></span><br></pre></td></tr></table></figure>

<h2 id="sort-陣列排序"><a href="#sort-陣列排序" class="headerlink" title="sort 陣列排序"></a>sort 陣列排序</h2><p>sort() 方法用來重新排序陣列中的元素，預設會將元素轉型成「字串」做比較，比較的方式是從左到右逐一比對元素中的每個字元的 Unicode code point 大小。</p>
<h3 id="字串排序"><a href="#字串排序" class="headerlink" title="字串排序"></a>字串排序</h3><p><img src="https://cdn-images-1.medium.com/max/1320/1*z2ppQd5xApaAlJjqeEzsqw.png"></p>
<h3 id="數字排序"><a href="#數字排序" class="headerlink" title="數字排序"></a>數字排序</h3><p><img src="https://cdn-images-1.medium.com/max/1320/1*0h6KmjMf7vl4m0xcF8PCSA.png"></p>
<h3 id="自定排序"><a href="#自定排序" class="headerlink" title="自定排序"></a>自定排序</h3><p><img src="https://cdn-images-1.medium.com/max/1320/1*_tzsJRXfE-3qj6lBZeU-nw.png"></p>
<p>(a, b) 函數接受兩個參數，分別表示兩個元素值怎麼做比較，然後傳回一個數字，可能是正數、0 或負數：</p>
<ul>
<li>(a, b) 回傳值如果小於 0 (負數)，表示 a 排序在 b 前面</li>
<li>(a, b) 回傳值如果等於 0，表示 a 和 b 排序一樣位置不動</li>
<li>(a, b) 回傳值如果大於 0 (正數)，表示 b 排序在 a 前面</li>
</ul>
<h3 id="日期排序"><a href="#日期排序" class="headerlink" title="日期排序"></a>日期排序</h3><p><img src="https://cdn-images-1.medium.com/max/1320/1*9LaeppvPar4XHz7MrxopWA.png"></p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*ApSomNizClW_MK5vbfWLSA.png"></p>
<p>將日期傳入 new Date()函式中，會返回一個 時間戳(timestamp)，再將兩個時間戳相減，可以做到日期的排序。</p>
<h2 id="reduce-陣列加總"><a href="#reduce-陣列加總" class="headerlink" title="reduce 陣列加總"></a>reduce 陣列加總</h2><p><img src="https://cdn-images-1.medium.com/max/1320/1*WLYU9gJM4hK0Cn408IukwQ.png"></p>
<p>reduce 會有一個 total 參數作為加總結果，本範例預設從 0 開始加，每運算一次會經過一筆資料(inventor)，運算的內容為 發明家過世年-出生年 一路累加下去，運算流程如下:</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*WS5Ce5AmGuksv8FhAejKqg.png"></p>
<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>some() 方法會透過給定函式、測試陣列裡的每個 item 是否符合條件，有一個符合條件，就回傳true 不然回傳false。</p>
<p><img src="https://cdn-images-1.medium.com/max/1320/1*F-tchb0UZv76sUS9yHb_Ew.png"></p>
<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>檢查陣列裡的物件，全部都符合條件，就回傳true 不然回傳false</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*E8ILL1afqzt52uxLiKQN1A.png"></p>
<h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><p>當我們的陣列內容很簡單時，比如只有字串或數字，而我們想檢查陣列是否有特定值時，可以用includes()方法，有值則回傳true，否則false</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*4Le_kfZHTKWL0UmBrNTupg.png"></p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>在陣列中尋找符合條件的資料，找到後回傳第一筆資料，否則回傳 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = array1.<span class="title function_">find</span>(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(found);</span><br><span class="line"><span class="comment">// expected output: 12</span></span><br></pre></td></tr></table></figure>

<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><p>在陣列中尋找符合條件的物件，找到後回傳第一筆物件的排序。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*VcWqnARGsPZYBhLouFqRQA.png"></p>
<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>splice() 方法可以藉由刪除既有元素並／或加入新元素來改變一個陣列的內容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">splice</span>(要插入或刪除的索引位置, 刪除筆數, 插入的元素)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> months = [<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;March&#x27;</span>, <span class="string">&#x27;April&#x27;</span>, <span class="string">&#x27;June&#x27;</span>];</span><br><span class="line">months.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;Feb&#x27;</span>);</span><br><span class="line"><span class="comment">// inserts at index 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(months);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]</span></span><br><span class="line"></span><br><span class="line">months.<span class="title function_">splice</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&#x27;May&#x27;</span>);</span><br><span class="line"><span class="comment">// replaces 1 element at index 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(months);</span><br><span class="line"><span class="comment">// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>slice() 方法會回傳一個新陣列物件，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。而原本的陣列將不會被修改。</p>
<p><img src="https://miro.medium.com/max/1400/1*CDZGHAJV-RjQ62NohMnyAQ.png"></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 DOM API 查找節點</title>
    <url>/2022/08/09/2022-8-9-1-js-dom-trace/</url>
    <content><![CDATA[<h2 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h2><p>選取特定id的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;bob&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bob = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bob&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="getElementByClassName"><a href="#getElementByClassName" class="headerlink" title="getElementByClassName"></a>getElementByClassName</h2><p>選取所有包含指定class的元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bob = <span class="variable language_">document</span>. <span class="title function_">getElementByClassName</span>(<span class="string">&#x27;card&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h2><p>querySelector 使用 css 選擇器來選取一個元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bob = <span class="variable language_">document</span>. <span class="title function_">querySelector</span>(<span class="string">&#x27;.card&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h2><p>querySelectorAll 使用 css 選擇器來選取多個元素，會回傳一個collection(不是陣列)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bob = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.card&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Node-children"><a href="#Node-children" class="headerlink" title="Node.children"></a>Node.children</h2><p>Node.children 會回傳所有Node 節點的子節點，會回傳一個collection。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container &quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.container&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cards = container.<span class="property">children</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Node-parentElement"><a href="#Node-parentElement" class="headerlink" title="Node.parentElement"></a>Node.parentElement</h2><p>透過 Node.parentElement 可以用來取得父元素，回傳值只會是一個元素節點 (Element node)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> card = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.card&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> parent = card.<span class="property">parentElement</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Node-closest"><a href="#Node-closest" class="headerlink" title="Node.closest"></a>Node.closest</h2><p>Node.closest 會一路往上找，取得符合條件的父元素。</p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*-En99lg7L95i7glPXF-PYA.png"></p>
<p><img src="https://cdn-images-1.medium.com/max/1200/1*QkZmAc54hcar7Iy-yVlOTw.png"></p>
<h2 id="Node-previousSibling"><a href="#Node-previousSibling" class="headerlink" title="Node.previousSibling"></a>Node.previousSibling</h2><p>透過 Node.previousSibling 可以取得同層之間的「前一個」節點，如果 node 已經是第一個節點，則回傳 null。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cardOne = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.card&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cardTwo = <span class="variable language_">document</span>.<span class="property">previousSibling</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Node-nextSibling"><a href="#Node-nextSibling" class="headerlink" title="Node.nextSibling"></a>Node.nextSibling</h2><p>與 Node.previousSibling 類似，透過 Node.nextSibling 可以取得同層之間的「下一個」節點，如果 node 已經是最後一個節點，則回傳 null。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cardOne = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.card&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cardTwo = <span class="variable language_">document</span>.<span class="property">nextSibling</span>;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM Node 的建立、刪除與修改</title>
    <url>/2022/08/07/2022-8-7-1-dom-manipulation/</url>
    <content><![CDATA[<h2 id="新增節點"><a href="#新增節點" class="headerlink" title="新增節點"></a>新增節點</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;element&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://miro.medium.com/max/922/1*YbdC8phChHpaXIwadplUhg.png"></p>
<p>透過 document.createElement() 可以建立一個新的元素，在建立新的 div 元素 newDiv 後，這時候我們在瀏覽器上還看不到它，直到透過 appendChild()、insertBefore() 或 replaceChild() 等方法將新元素加入至指定的位置之後才會顯示。</p>
<h3 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="createDocumentFragment"></a>createDocumentFragment</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br></pre></td></tr></table></figure>

<p>createDocumentFragment() 是一種沒有父層節點的「最小化文件物件」。 可以把它看作是一個輕量化的 Document，用如同標準文件一般的方式來保存「片段的文件結構」。</p>
<p><img src="https://miro.medium.com/max/1354/1*IhyIKgVykoa64qi5s2Q4wQ.png"></p>
<h2 id="插入節點"><a href="#插入節點" class="headerlink" title="插入節點"></a>插入節點</h2><p>接下來要介紹的幾個方法，說明要如何將剛剛建立好的 DOM 節點，置入到我們所指定的位置。</p>
<h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">NODE</span>.<span class="title function_">appendChild</span>(childNode)</span><br></pre></td></tr></table></figure>

<p>透過 appendChild 方法，可以將指定的 childNode 節點，加入到 Node 父容器節點的末端：</p>
<p><img src="https://miro.medium.com/max/1400/1*Duv1uiJyztP5av1hgMhwoA.png"></p>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">NODE</span>.<span class="title function_">append</span>(childNode || <span class="title class_">String</span>)</span><br></pre></td></tr></table></figure>

<p>和appendChild 一樣將節點加入父層末段，但除了節點以外，也能加入字串。</p>
<h2 id="刪除節點"><a href="#刪除節點" class="headerlink" title="刪除節點"></a>刪除節點</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">remove</span>()  <span class="comment">// 刪除節點</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> child = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.child&#x27;</span>);</span><br><span class="line">div.<span class="title function_">removeChild</span>(child) <span class="comment">// 刪除子元素</span></span><br></pre></td></tr></table></figure>

<h2 id="操作元素的屬性"><a href="#操作元素的屬性" class="headerlink" title="操作元素的屬性"></a>操作元素的屬性</h2><h3 id="取得屬性內容"><a href="#取得屬性內容" class="headerlink" title="取得屬性內容"></a>取得屬性內容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">getAttribute</span>(<span class="string">&#x27;id&#x27;</span>) <span class="comment">//hi</span></span><br><span class="line">div.<span class="property">id</span> <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<h3 id="設定屬性內容"><a href="#設定屬性內容" class="headerlink" title="設定屬性內容"></a>設定屬性內容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>); <span class="comment">// 將id屬性設為 hi</span></span><br></pre></td></tr></table></figure>

<h3 id="移除屬性"><a href="#移除屬性" class="headerlink" title="移除屬性"></a>移除屬性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bob&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;title&#x27;</span>); <span class="comment">// 將titile屬性移除</span></span><br></pre></td></tr></table></figure>

<h3 id="data屬性操作"><a href="#data屬性操作" class="headerlink" title="data屬性操作"></a>data屬性操作</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-test</span>=<span class="string">&quot;this is a test&quot;</span> <span class="attr">data-num</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">dataset</span>.<span class="property">test</span> <span class="comment">// this is a test</span></span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">num</span> <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h2 id="操作元素的class"><a href="#操作元素的class" class="headerlink" title="操作元素的class"></a>操作元素的class</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;new-class&#x27;</span>); <span class="comment">// 新增class</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;new-class&#x27;</span>); <span class="comment">// 移除class</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;new-class&#x27;</span>); <span class="comment">// 有class則移除class，沒有則加入該class</span></span><br></pre></td></tr></table></figure>

<h2 id="直接操作元素的css"><a href="#直接操作元素的css" class="headerlink" title="直接操作元素的css"></a>直接操作元素的css</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">div.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;black&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="新增文字"><a href="#新增文字" class="headerlink" title="新增文字"></a>新增文字</h2><p>新增文字有兩種方法 textContent 、 innerText</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">innerText</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">div.<span class="property">textContent</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>兩個方法都能加入文字，但innerText只顯示會出現螢幕上的文字，textContent則顯示全部文字。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span>Tim<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">textContent</span>); <span class="comment">// Hello Tim</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">innerText</span>); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>


<h2 id="新增-html"><a href="#新增-html" class="headerlink" title="新增 html"></a>新增 html</h2><p>innerHTML 可以在元素內加入 html 結構，並清除元素原有內容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;span&gt;Hello&lt;span&gt;&#x27;</span></span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
</search>
